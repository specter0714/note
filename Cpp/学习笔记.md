

[TOC]

# 笔记

## C

### 运算符

1. `&`：按位与运算符，用于执行二进制位的与操作，将两个操作数的每个位进行与操作。

   ​	按位与运算符 `&` 用于执行二进制位的按位与操作。它将两个整数的二进制表示的每个位进行与运算，产生一个新的整数作为	结果。

   ​	运算规则如下：

   - 如果两个位都为1，结果的对应位就是1。

   - 如果任一位为0，结果的对应位也是0。

     示例：

   ```c++
   int a = 5;  // 二进制表示为 0101
   int b = 3;  // 二进制表示为 0011
   
   int result = a & b;  // 结果是 1（十进制），二进制表示为 0001
   ```

   

   ​			另：int& s 和 int s 表示两个不同类型的变量声明。

   1. int& s 声明了一个 int 类型的引用变量 s。引用是一个别名，它引用了已经存在的变量或对象。这意味着 s 是已经存在的某个 int 变量的别名，对 s 的修改会直接反映到原始变量上。

   示例：
   ```
   int x = 5;
   int& s = x; // s 是 x 的引用
   s = 10;    // 修改 s 也会修改 x 的值
   ```

   注意：int& s 声明的是引用变量，而 int s 声明的是普通变量。它们有不同的语义和用途，请根据需求选择正确的方式。



1. `|`：按位或运算符，用于执行二进制位的或操作，将两个操作数的每个位进行或操作。

   ​	按位或运算符 `|` 用于执行二进制位的按位或操作。它将两个整数的二进制表示的每个位进行或运算，产生一个新的整数作为	结果。

   ​	运算规则如下：

   - 如果任一位为1，结果的对应位就是1。

   - 如果两个位都为0，结果的对应位也是0。

     示例：

   ```c++
   int a = 5;  // 二进制表示为 0101
   int b = 3;  // 二进制表示为 0011
   
   int result = a | b;  // 结果是 7，二进制表示为 0111
   ```

2. `^`：按位异或运算符，用于执行二进制位的异或操作，将两个操作数的每个位进行异或操作。

   它对两个操作数进行逐位异或运算

​				如果对应位上的两个操作数不同，则结果为1，否则为0。

1. `~`：按位取反运算符，用于执行二进制位的取反操作，将每个位取反。

2. `>>`：右移运算符，用于将二进制位向右移动指定数量的位数。

3. `>>=`：右移赋值运算符，将右移操作的结果赋值给左侧操作数。

4. `<<`：左移运算符，用于将二进制位向左移动指定数量的位数。

5. `<<=`：左移赋值运算符，将左移操作的结果赋值给左侧操作数。

6. `()? :`：条件运算符（三元运算符），用于根据条件的真假选择不同的值。

### 随机数

#### 	作用

​	测试数据

#### 	方法

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main (void) {
	srand((unsigned)time(NULL));
	int a = rand();
	printf ("%d", a);
	return 0;
}
```

srand是"stdlib.h"里的函数，time是"time.h"里的函数

随机数的范围一般来说认定为是0~32767之间的一个整数

要是想要某个范围的随机数，比如0~34之间的数字，要这么操作

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main (void) {
	srand((unsigned)time(NULL));
	int a = rand() % 35;
	printf ("%d", a);
	return 0;
}
```



要是想要2~17之间的随机数，要这么操作

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main (void) {
	srand((unsigned)time(NULL));
	int a = rand() % 15 + 2;
	printf ("%d", a);
	return 0;
}
```

### math库

ceil(x)返回大于等于x的最小double类型的整数

floor(x)返回小于等于x的最大double类型的整数

modf (double x, double* y)，返回x的小数部分，并将整数部分赋值给y

hypot(x, y)返回sqrt(pow(x, 2) + pow(y, 2))，就是把x和y当两条直角边，求斜边

## C++

### iostream库

#### cin

#### cout

#### getline

可输入一行字符，可接受空格

#### cin.get

输入单个字符，可接受空格



### algorithm库

#### 1.max和min

取两个相同类型数据中的最值

在algorithm头文件下的max有这样的使用方法(C++11)：

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int main (void) {
	cout << max ({3, 5, 4, 1, 2}); // 输出：5
    return 0;
}

```

而**iostream下的max不支持这么用**

最后这种方法对数组和vector用均会报错

#### 2.abs

返回整数绝对值

#### 3.swap

交换两个变量数据

#### 4.reverse

将指定区间或迭代器范围内的元素反转

数组的话，传两个指针，左闭右开（下面的这种形式的不做说明均为**左闭右开区间**）

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	reverse(a+1, a+4);
	for (int i : a) {
		printf ("%d ", i);
	}	// 输出：1 4 3 2 5 
    return 0;
}
```

迭代器

```c++
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int main (void) {
	vector<int> a = {1, 2, 3, 4, 5};
	reverse(a.begin(), a.end());
	for (int i : a) {
		printf ("%d ", i);
	}	// 输出：5 4 3 2 1 
    return 0;
}
```

#### 5.next_permutation

bool next_permutation (T *it1, T *it2)

将区间内的元素变为下一个全排列序列，返回值意思为：是否还有下一个全排列

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main (void) {
	int a[5] = {1, 1, 3, 2, 2};
	do {
		printf ("%d %d %d %d\n", a[1], a[2], a[3], a[4]);
	} while (next_permutation(a+1, a+5));
    return 0;
}
```

输出如下：

```c++
1 3 2 2
2 1 2 3
2 1 3 2
2 2 1 3
2 2 3 1
2 3 1 2
2 3 2 1
3 1 2 2
3 2 1 2
3 2 2 1
```

#### 6.fill

```c++
void fill (T *it1, T *it2, val)
```



##### 对数组赋值

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	fill (a+1, a+4, 233);
	for (auto i : a) {
		printf ("%d ", i);
	}	// 输出：1 233 233 233 5 
    return 0;
}
```



##### 如果对二维数组填充

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int a[4][5];

int main (void) {
	fill (a[1], a[1]+12, 4);
	for (int i = 0; i < 4; ++i) {
		for (int j = 0; j < 5; ++j) {
			printf ("%d ", a[i][j]);
		}
		putchar ('\n');
	}
    return 0;
}
/*输出如下：
0 0 0 0 0 
4 4 4 4 4 
4 4 4 4 4 
4 4 0 0 0 

*/
```

##### 对vector填充

```c++
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

vector<int> a(5, 1);

int main (void) {
	fill (a.begin(), a.begin() + 4, 3);
	for (int i = 0; i < a.size(); ++i) {
		printf ("%d ", a[i]);
	}	// 输出： 3 3 3 3 1  
    return 0;
}

```

不能对二维vector使用

#### 7.sort

##### 1.使用

```c++
void sort (T *it1, T *it2)
void sort (T *it1, T *it2, bool (*func)(T, T))
```

##### 2.普通元素排序

第二个sort的第三个参数是函数，可以自定义比较规则

```c++
#include<csdio>
#include<algorithm>
using namespace std;

bool cmp (int a, int b) {
    return a>=b;//>=从大到小排序
}

int main(){
    int a[5]={0, 4, 3, 2, 1};
    sort(a+1, a+4);
    for (int i : a){
        printf("%d",i);
    }//输出 0 2 3 4 1//默认小到大
    putchar('\n');
    sort (a, a+3,cmp);
    for (int i : a){
        printf("%d");
    }//输出//3 2 0 4 1//大到小
}
```

第三个参数要写一个能返回bool的函数(int也行，毕竟C语言以1和0表示bool)

##### 3.ambda表达式(C++11)

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

int main (void) {
	int arr[5] = {3, 5, 4, 1, 2};
	sort (arr, arr+5, [](int a, int b)->bool{
		return a > b;
	});
	for (int i : arr) {
		printf ("%d ", i);
	}	// 输出：5 4 3 2 1 
    return 0;
}
```

Lambda 表达式是一种匿名函数（函数对象）的表示方式，它允许我们在需要函数的地方编写简洁的、临时的函数定义。

Lambda 表达式的一般语法形式如下：

```c++
[捕获列表](参数列表) -> 返回类型 { 函数体 }
```

其中：
- 捕获列表（Capture List）：用于捕获外部变量，并使其在 lambda 表达式内可用。可以为空，也可以包含一个或多个变量。捕获列表可以按值（使用 `=`）或按引用（使用 `&`）进行捕获。

- 捕获列表有三种形式：

  1. 空捕获列表 `[]`：

     - 当 Lambda 表达式不需要访问任何外部变量时，可以使用空的捕获列表。
     - 在这种情况下，Lambda 表达式只能使用函数体中定义的局部变量，无法访问外部作用域的变量。

  2. 值捕获列表 `[变量名1, 变量名2, ...]`：

     - 通过值捕获列表，可以将指定的外部变量拷贝到 Lambda 表达式的函数体中，使其在 Lambda 表达式内部可用。

     - 值捕获会创建变量的副本，Lambda 表达式内部对副本的修改不会影响原始变量。

     - ```c++
       int x = 5;
       auto lambda = [x]() {
           // 在 Lambda 表达式中访问值捕获的变量 x
           std::cout << "Value captured variable: " << x << std::endl;
       };
       lambda();  // 输出: Value captured variable: 5
       ```

       

  3. 引用捕获列表 `[&变量名1, &变量名2, ...]`：

     - 通过引用捕获列表，可以通过引用的方式访问指定的外部变量，而不是创建副本。

     - 引用捕获允许在 Lambda 表达式内部修改外部变量，并且修改会反映在原始变量上。

     - ```c++
       int y = 10;
       auto lambda = [&y]() {
           // 在 Lambda 表达式中通过引用访问外部变量 y
           y += 5;  // 修改外部变量 y
           std::cout << "Modified variable: " << y << std::endl;
       };
       lambda();  // 输出: Modified variable: 15
       std::cout << "Original variable: " << y << std::endl;  // 输出: Original variable: 15
       ```

       

- 参数列表（Parameter List）：用于定义 lambda 表达式的参数。可以为空，也可以包含一个或多个参数。

- 返回类型（Return Type）：用于指定 lambda 表达式的返回类型。可以省略，编译器会自动推导返回类型。

- 函数体（Function Body）：lambda 表达式的具体实现代码。

下面是一个简单的 lambda 表达式的示例，用于计算两个整数的和：

```cpp
auto sum = [](int a, int b) -> int {
    return a + b;
};
```

在上面的示例中，`[]` 表示空的捕获列表，`(int a, int b)` 是参数列表，`-> int` 指定了返回类型为 `int`，`{ return a + b; }` 是函数体实现。

Lambda 表达式可以用于多种场景，例如作为函数对象、作为参数传递给其他函数、用于算法函数等。它提供了一种便捷的方式来编写简洁、灵活的函数代码。

##### 4.greater和less

这俩是在functional头文件中的，一般不写

有的编译器只要写algorithm就能用

有的编译器要写iostream才能用

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
int main(){
     int a[5]={2, 1, 3, 4 ,5};
    sort(a, a+5, greater<int>());
    for (int i : a){
        printf ("%d",i);//输出5 4 3 2 1 
    }
    putchar ('\n');
    sort (a, a+5, less<int>());
    for (int i : a){
        printf("%d",i);
    }
}
```

##### 5.结构体排序

```c++
#include<iostream>
#include<algorithm>
using namespace std;
struct test {
    int num1;
    int num2;
};
bool cmp(test a, test b) {
    if (a.num1 == b.num1) {
        return a.num2 >= b.num2;
}
    return a.num1 <= b.num1;
}
int main() {
    test a[5] = { {2, 3}, {4, 3}, {4, 5}, {4, 4}, {5, 1} };
    sort(a, a + 5, cmp);
    for (test i : a) {
        printf("%d %d\n", i.num1, i.num2);
    }
}
```

输出如下：

```
2 3
4 5
4 4
4 3
5 1

```

##### 6.字符串排序

参考string那一节

##### 7.pair排序

#### 8.max_element和min _element

返回区间内最大/小值的指针或者迭代器

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main () {
    int a[5]={5, 4, 3, 2, 1};
    printf("%d %d", max_element(a, a + 5) - a, min_element(a, a + 5) - a);
}
```

如果并列最大/最小，则返回最靠前位置的 指针/迭代器

要注意它返回的不是直接坐标，最后需要-a

#### 9.find

T* find (T *it1, T *it2, val)

在指定区间内从左往右找第一个出现val的指针/迭代器并返回

如果没找到，返回it2(即区间的末尾)这个迭代器标识着容器的边界，而不是实际的元素。

当然也可以查找字符或者字符串

```c++
#include <iosstream>
#include <algorithm>
using namespace std;
int main () {
    int a[5]={5, 4, 3, 2, 1};
    int *x=&find(a, a+5, 3)-a;
    cout<<*x;
}
```

注意这个也要-a

string vector那一节还会用到



`std::find` 函数期望查找的值与容器中存储的值类型相同。当搜索类型不匹配时，对于这种情况，可以使用 `std::find_if` 替代 `std::find`。

`std::find_if` 是一个在 C++ 标准库中定义的算法，属于 `<algorithm>` 头文件。它用于在给定的范围内查找第一个满足特定条件的元素。它需要两个迭代器（表示搜索开始和结束的范围）和一个谓词（一个返回布尔值的函数或函数对象），用于测试每个元素是否满足条件。

下面是 `std::find_if` 的基本用法示例：

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

bool is_odd(int n) {
    return (n % 2) == 1;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 9, 10};

    // 使用 find_if 查找第一个奇数
    auto it = std::find_if(vec.begin(), vec.end(), is_odd);

    if (it != vec.end()) {
        std::cout << "第一个奇数是: " << *it << std::endl;
    } else {
        std::cout << "没有找到奇数" << std::endl;
    }

    return 0;
}
```

在这个例子中，`std::find_if` 会从 `vec` 的开始迭代，使用 `is_odd` 函数来检查每个元素。它返回指向第一个满足条件（在这个例子中是第一个奇数）的迭代器。如果没有找到满足条件的元素，`std::find_if` 将返回结束迭代器 `vec.end()`。

#### 10.lower_bound和upper_bound

```c++
T* lower_bound(T* it1, T* it2, E& val)
```

用**二分**查找取寻找区间内第一个**大于等于**val的指针/迭代器并返回

```c++
T* upper_bound(T* it1, T* it2, E& val)
```

用**二分**查找取寻找区间内第一个**大于**val的指针/迭代器并返回

注意这两个函数要求在**升序**数组或容器中才能顺利使用

```c++
#include <iostream>
#inlcude <algorithm>
using namespace std;
int main () {
    int a[5] = {1, 2, 2, 4, 5};
    cout<<lower_bonnd(a, a+5, 2) - a<<' '<<upper_bound(a, a+5, 2) - a;
     
}
```

#### 11.unique

该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素

- 这里的去除并非真正意义的去除，而是将重复的元素放到容器的末尾，返回值是**去重之后的尾地址**。
- unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要**先进行排序**，可以调用std::sort()函数

使用示例:

```c++
#include <iostream>
#include <algorithm>
int main(void){
    int a[8] = {2, 2, 2, 4, 4, 6, 7, 8};
    int c;
    std::sort(a, a + 8);  //对于无序的数组需要先排序
    c = (std::unique(a, a + 8) - a );
    std::cout<< "c = " << c << std::endl;//去重函数返回地址为：去重后最后一个不重复元素地址
    //打印去重后的数组成员
    for (int i = 0; i < c; i++)
        std::cout<< "a = [" << i << "] = " << a[i] << std::endl;
    return 0;
}
12345678910111213
```

运行结果：

返回值`c`等于`5`，而a数组的前5项为`2、4、6、7、8`。

对于容器的操作类似:

```c++
std::vector<int> ModuleArr;
//排序
std::sort(ModuleArr.begin(), ModuleArr.end());
//去重
ModuleArr.erase(unique(ModuleArr.begin(), ModuleArr.end()), ModuleArr.end());
```



### vector库

vector容器，类似于可变长数组

#### 1.创建

```c++
#include(vector)
using namespace std;
int main(){
    vector<int> arr;
    return 0;
}
```

尖括号内写你想向容器中存的数据类型



```c++
vector<int> arr(10);
```

这样是定义了该容器的容量为10，值默认均为0(其他编译器可能会不同)

注意容量只是暂时定为10，如果需要再向容器中添加元素(指push_back)，它会自动扩容



```c++
vector<int> arr(10, 3);
```

这样是定义了该容器的容量为10，值均为3



```c++
vector<int> arr = {3, 5, 4, 1, 2};
vector<int> brr {3, 5, 4, 1, 2};//可以没有等号
```

这样赋值在C++11标准才有



```c++
vector<int> brr {3, 5, 4, 1, 2};
vector<int> arr(brr);
```

将brr容器整体复制给arr容器



```c++
vector<int> brr {3, 5, 4, 1, 2};
vector<int> arr(brr.begin()+1, brr.begin()+3);//brr为容器，所以是brr.begin（）+1
```

将brr容器指定区间复制给arr容器

arr.begin()是返回arr容器的起始迭代器 



```c++
int brr[5] = {3, 5, 4, 1, 2};
vector<int> arr(brr+1, brr+3);//brr为数组，所以是brr+1
```

将指定数组区间复制给arr容器



```c++
vector<vector<int> > a;
```

定义二维vector，取数据时可当作二维数组



```c++
vector<vector<int> > a(3, vector<int>(2, 4));
```

二维vector初始化，这句意思是，第一维长度为3，第二维长度为2，值均为4(其实就是创建了个三行两列的数组，且值均为4)

#### 2.assign

 

```c++
vector<int> brr {3, 5, 4, 1, 2};
vector<int> arr;
arr.assign(brr.begin()+1, brr.begin()+3);
```

将向量brr指定区间的元素复制给arr容器

相当于清空arr容器(容量不变，超出会自动扩容)，再将指定区间赋值给arr容器



```c++
vector<int> arr = {3, 5, 4, 1, 2};
arr.assign(2, 3);
```

将arr清空(容量不变，超出会自动扩容)，然后赋上两个3

#### 3.push_back、取出元素、容量

想要向容器中添加元素

```c++
arr.push_back(2);
```

就从容器的末尾插入了一个2

```
arr.size（）
```

返回arr容器中的元素个数



```c++
arr.capacity()
```

返回当前容器的容量数



想手动更改容量

```c++
arr.reserve(x)
```

将当前容器的容量改为x

#### 4.front、back、clear、empty、pop_back、swap



```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr {3, 5, 4, 1, 2};
	printf ("%d %d", arr.front(), arr.back());
    // 输出：3 2
    return 0;
}
```

arr.front()返回容器第一个元素

arr.back()返回容器最后一个元素



arr.clear()清空容器(但容量不变)

arr.empty()判断容器是否为空，为空则返回true，否则返回false

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr {3, 5, 4, 1, 2};
	arr.pop_back();
	printf ("%d", arr.back());
    // 输出：1
    return 0;
}
```

```
arr.pop_back()
```

删除最后一个元素



```
arr.swap(brr)
```

将两个同类型的vector容器交换

#### 5.迭代器

与指针区别：

- 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->,*,++ --等封装了指针，是一个**可遍历STL（ Standard Template Library）容器内全部或部分元素的对象**， 本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作；

- 迭代器返回的是**对象引用**而不是对象的值，所以cout只能输出迭代器使用 *取值后的值而不能直接输出其自身。

- 在设计模式中有一种模式叫 **迭代器模式**，简单来说就是提供一种方法，在不需要暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素，这种设计思维在STL中得到了广泛的应用，是STL的关键所在，通过 迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。

- ```c++
  ite=find(vec.begin(),vec.end(),88);
  vec.insert(ite,2,77);  //迭代器标记的位置前，插入数据；
  cout<<*ite<<endl;  //会崩溃，因为迭代器在使用后就释放了，*ite的时候就找不到它的地址了；
  ```

- 迭代器在使用后就释放了，不能再继续使用，但是指针可以！！

- 指针能指向函数而迭代器不行，迭代器只能指向容器；

- 指针是迭代器的一种。指针只能用于某些特定的容器；

- 迭代器是指针的抽象和泛化。所以，指针满足迭代器的一切要求。

​        总之，指针和迭代器是有很大差别的，虽然他们表现的行为相似，但是本质是不一样的！一个是类模板，一个是存放一个家伙的地址的指针变量。

————————————————
版权声明：本文为CSDN博主「戎·码一生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gogokongyin/article/details/51206225

普通的迭代器的创建方式如下：

```c++
//容器类型的名字::iterator 迭代器变量名
vector<int>::iterator it;
```

但现在只是创建了一个迭代器变量，它没有指向任何容器，所以要给它赋值



使用arr.begin()可以返回arr容器的初始迭代器，指向了第一个位置

使用arr.end()可以返回arr容器的末尾迭代器，指向了最后一个位置的下一个位置，见下图

一般将arr.begin()赋给迭代器，让迭代器指向初始位置，将arr.end()作为遍历容器的结束条件

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr {3, 5, 4, 1, 2};
	vector<int>::iterator it;
	for (it = arr.begin(); it != arr.end(); ++it) {
		printf ("%d ", *it);
	}	// 输出：3 5 4 1 2 
    return 0;
}
```



迭代器之间可以进行`==` `!=` 比较

两个同类型(数据类型和迭代器类型)的迭代器之间可以相互赋值

迭代器还有反向迭代器，下面做一个演示

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

int main (void) {
	vector<int> arr {3, 5, 4, 1, 2};
	vector<int>::reverse_iterator it;
	for (it = arr.rbegin(); it != arr.rend(); ++it) {
		printf ("%d ", *it);
	}
    return 0;
}
```

反向迭代器的++it相当于往arr.rend()方向移动到下一个元素



迭代器还可以按功能分类，有五种，平常能用上的就下面表格中的三种



| 容器          | 迭代器功能 |
| ------------- | ---------- |
| vector        | 随机访问   |
| deque         | 随机访问   |
| list          | 双向       |
| set           | 双向       |
| unordered_set | 双向       |
| map           | 正向       |
| unordered_map | 正向       |



正向迭代器就是上面讲的操作都有

双向迭代器包含正向迭代器的功能，额外有--it和it--的操作，往++it和it++的反方向移动

双向迭代器使用prev()可以返回上一个迭代器

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector <int> a = {3, 5, 4, 1, 2};
	vector <int> :: iterator it;
	it = prev (a.end());
	printf ("%d", *it);
    // 输出：2
    return 0;
}

```

可以在第二个参数写一个整数x，表示返回上x个迭代器

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector <int> a = {3, 5, 4, 1, 2};
	vector <int> :: iterator it;
	it = prev (a.end(), 3);
	printf ("%d ", *it);	// 输出：4
	it = prev (it, -1);
	printf ("%d ", *it);	// 输出：1
    return 0;
}

```





随机访问迭代器包含双向迭代器的功能，它还能进行以下操作

若i是一个整型变量或常量

p + i	返回后面第i个元素的迭代器

p - i	返回前面第i个元素的迭代器

p += i	让p向后移动i个元素

p -= i	让p向前移动i个元素

p[i]		返回p后第i个元素的引用

还支持`<` `>` `<=` `>=` 运算符之间比较，是按照位置比较的

谁距离arr.end()末尾迭代器的距离近谁大

反向迭代器的话就是越靠近arr.rend()越大

还支持it2-it1，得到的是迭代器之间间隔几个数据

#### 6.insert和erase

insert可以向容器中插入元素

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	int t[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
	vector<int> arr{1, 2, 3, 4, 5};
	vector<int> brr{1, 2, 3, 4, 5};
	vector<int> crr{1, 2, 3, 4, 5};
	arr.insert(arr.begin()+1, 3);
	brr.insert(brr.begin()+2, 4, 1);
	crr.insert(crr.begin()+4, t+1, t+7);
	
	for (int i : arr) {
		printf ("%d ", i);
	}
	putchar('\n');
	for (int i : brr) {
		printf ("%d ", i);
	}
	putchar('\n');
	for (int i : crr) {
		printf ("%d ", i);
	}
	
    return 0;
}

```

输出如下：

```
1 3 2 3 4 5 
1 2 1 1 1 1 3 4 5 
1 2 3 4 9 8 7 6 5 4 5 
```

三个insert代表不同的用法

第一个是在迭代器指向的位置插入一个元素3

第二个是在迭代器指向的位置开始插入4个1

第三个是在迭代器指向的位置开始插入数组中从t+1到t+7区间的数

第三个insert后两个参数也可以是其他同类型的迭代器区间



使用erase可以删除容器的一个区间

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr{1, 2, 3, 4, 5};
	arr.erase(arr.begin()+1, arr.begin()+3);
	for (int i : arr) {
		printf ("%d ", i);
	}	// 输出：1 4 5 
    return 0;
}

```





在使用迭代器遍历时，使用erase可以删除某个迭代器指向的元素，并返回下一个迭代器的位置

这里我想删除容器中所有的1

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr{1, 2, 1, 4, 5};
	vector<int>::iterator it;
	for (it = arr.begin(); it != arr.end(); ++it) {
		printf ("%d ", *it);
		if (1 == *it) {
			it = arr.erase(it);
		}
	}
    return 0;
}

```

输出：1 1 5 

只输出了三个数，因为删除元素后，迭代器指向的下一位置赋值给了it

然后for循环第二个分号后面又++it，所以就少遍历了两个元素



```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr{1, 2, 1, 4, 5};
	vector<int>::iterator it;
	for (it = arr.begin(); it != arr.end(); ++it) {
		printf ("%d ", *it);
		if (1 == *it) {
			arr.erase(it);
		}
	}
    return 0;
}

```

如果我不把erase的返回值赋给it

输出：1 1 5 

和上面一样

说明**erase函数在执行时，会自动把it指向下一位置**



要想成功遍历所有元素，要这么写

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr{1, 2, 1, 4, 5};
	vector<int>::iterator it;
	for (it = arr.begin(); it != arr.end(); ) {
		printf ("%d ", *it);
		if (1 == *it) {
			arr.erase(it);
		} else {
			++it;
		}
	}
    return 0;
}

```

输出：1 2 1 4 5 





使用erase与unique进行配合，可以很方便对vector容器去重

```c++
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

int main (void) {
	vector<int> arr{1, 1, 2, 3, 3};
	arr.erase(unique(arr.begin(), arr.end()), arr.end());
	for (unsigned i = 0; i < arr.size(); ++i) {
		printf ("%d ", arr[i]);
	}	// 输出：1 2 3 
    return 0;
}

```

注意，去重前一定要先保证vector是升序状态



原理不懂的先去复习unique是做什么的

unique先进行一波移动，把重复元素移动到后面，并返回无重复的右边界

然后使用erase对下界到end之间的元素删除



使用迭代器遍历时用insert中插入元素

这里我想在每个1前面添加一个0

```c++
#include <cstdio>
#include <vector>
using namespace std;

int main (void) {
	vector<int> arr{1, 2, 1, 4, 5};
	vector<int>::iterator it;
	for (it = arr.begin(); it != arr.end();) {
		if (1 == *it) {
			it = arr.insert(it, 0);
			++it;
			++it;
		} else {
			++it;
		}
	}
	for (it = arr.begin(); it != arr.end(); ++it) {
		printf ("%d ", *it);
	}	// 输出：0 1 2 0 1 4 5 
    return 0;
}

```

注意，insert那里插入元素后，会将迭代器移动到新插入元素的位置，并返回该位置

所以那里不赋值给it也行



两次++it的原因，自己模拟一下这个过程就明白了

#### 7.find

在C++中，可以使用 `std::find` 算法从 `std::vector` 中搜索特定元素，并返回指向该元素的迭代器。如果元素未找到，`std::find` 将返回指向容器末尾的迭代器,这个迭代器标识着容器的边界，而不是实际的元素。

```cpp
#include <vector>
#include <algorithm> // for std::find
using namespace std;
int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    int target = 3;

    vector<int>::iterator it = find(vec.begin(), vec.end(), target);
    
    if (it != vec.end())
    {
        // 找到目标元素
        std::cout << "Element found at index " << std::distance(vec.begin(), it);
    }
    else
    {
        // 未找到目标元素
        std::cout << "Element not found in vector";
    }

    return 0;
}
```

`std::find`在找到第一个匹配的元素后就会停止搜索并返回一个指向它的迭代器。所以如果数组中有多个要查找的元素，`std::find`只会返回第一个匹配的元素的迭代器。

如果想找到所有匹配的元素，可以在找到每个匹配的元素后，从该元素的下一个位置开始继续查找，直到`std::find`返回数组的末尾为止。

```cpp
#include <vector>
#include <algorithm> // for std::find

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 3, 6, 3};
    int target = 3;

    std::vector<int>::iterator it = vec.begin();

    while ((it = std::find(it, vec.end(), target)) != vec.end())
    {
        std::cout << "Element found at index " << std::distance(vec.begin(), it) << std::endl;
        it++; // move the iterator to the next position for the next search
    }

    return 0;
}
```

在这个例子中，我们从`vec.begin()`开始查找目标元素3，每次找到一个匹配的元素后，就将迭代器向前移动一位，然后从这个新位置开始继续查找。这样可以找到数组中所有的匹配元素。

如果想输出查找到的元素在数组（或向量）中的位置（即它是第几个元素），可以使用 `std::distance` 函数计算从向量开始迭代器到找到的元素的迭代器之间的距离。这个距离加1就给出了元素的位置（因为通常我们从1开始计数，而不是从0）。

```cpp
#include <vector>
#include <algorithm> // for std::find
#include <iostream>  // for std::cout

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 3, 6, 3};
    int target = 3;

    std::vector<int>::iterator it = std::find(vec.begin(), vec.end(), target);
    
    if (it != vec.end()) {
        // 找到了元素，输出它是第几个元素
        std::cout << "The first occurrence of the element is at position: " << std::distance(vec.begin(), it) + 1 << std::endl;
    } else {
        // 未找到元素
        std::cout << "Element not found in vector." << std::endl;
    }

    return 0;
}
```



### string/ctsring库

#### 1创建

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str1 = "hello world!";
	string str2 ("hello world!");
	string str3 (str2);
	string str4 (5, 'c');
	string str5;	// 此时str5为空串 
	str5 = "hello world";
	
	cout << str1 << '\n';
	cout << str2 << '\n';
	cout << str3 << '\n';
	cout << str4 << '\n';
	cout << str5 << '\n';
    return 0;
}
```

输出如下：

```
hello world!
hello world!
hello world!
ccccc
hello world

```



注意，string类型由于是C++的数据类型，所以**C语言的scanf和printf没办法对该类型输入输出**

**对string类型一般输入输出用cin和cou**t



使用cin读入string，遇到空白就会停止读入

如果我想读入带空格的字符串，使用getline读取

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str;
	getline (cin, str);
	cout << str;
    return 0;
}
```

getline第一个参数写cin，固定写法，想了解的自己查

第二个参数写string类型的变量，表示把读入的字符串读给该变量



还有一个是对char数组的读入

用cin.getline()

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	char c[100];
	cin.getline(c, 100);
	cout << c;
    return 0;
}
```

cin.getline第一个参数写char数组的变量名

第二个参数写你想读入的最大长度，默认遇到换行就停止读入

可以有第三个参数，写一个字符，表示遇到该字符就停止读入



注意不要把cin.getline和getline搞混了



#### 2访问



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str = "hello world!";
	for (int i = 0; i < str.length(); ++i) {
		printf ("%c", str[i]);
	}	// 输出：hello world!
    return 0;
}
```

前面说不能用printf，是不能用printf将整个字符串一起输出，我这里是对每个char类型输出，不矛盾

str.length()可以获取该字符串的长度

str.size()也可以，和str.length()的效果一样



遍历一个字符串也可以用迭代器，可以但没必要



#### 3拼接

##### append

使用append拼接(不常用)

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str1("hello");
	string str2(" world");
	char c[] = " 123";
	str1.append(str2.begin(), str2.end());
	str1.append(c);
    str1.append(c, 3);
	str1.append(str2);
    str1.append(str2, 3, 2);
	str1.append(3, 'R');
    str1.push_back('A');
	cout << str1;
    // hello world 123 12 worldrlRRRA
    return 0;
}
```

append有一堆重载

str1.append(str2.begin(), str2.end());这个是对区间进行截取并拼接到str1的后面

区间可以是迭代器之间的区间，也可以是char数组中指针的区间



str1.push_back('A')，可以向后面拼接一个字符

str1.append(3, 'R');向str1字符串的后面拼接三个字符R

str1.append(c);是直接把c数组中的字符串整个拼接到str1的后面

str1.append(str2);把整个str2字符串拼接到str1的后面



str1.append(c, 3);是把c数组从起始位置往后截取三个字符，拼接到str1的后面

str1.append(str2, 3, 2);对str2字符串从下标3开始往后截取两个字符拼接到str1的后面





可以使用str1.assign()对str1字符串进行重构，参数和append的那些参数基本相同，不演示了



虽然功能很多，但其实append并不常用

##### 内置的重载运算符

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str;
	string str1("hello");
	string str2(" world");
	char c[] = " 123";
	str = str1 + str2 + c;
	str += " " + str1 + str2;
	cout << str;
    // 输出：hello world 123 hello world
    return 0;
}
```

简洁明了，非常方便

#### 4比较

##### compare

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str1("aab");
	string str2("abb");
	cout << str1.compare(str2);
    // 输出：-1
    return 0;
}
```

compare的返回值和c语言的strcmp相同

compare的那些重载的参数和上面那个append一样



##### 内置的重载运算符

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str1("aab");
	string str2("abb");
	cout << (str1 <= str2);
    // 输出：1
    return 0;
}
```

注意cout << (str1 <= str2);这里我打了括号，因为不打括号会优先认为是进行`<<`左移运算符



当然肯定还可以进行`==` `!=` `>=` `<` `>` 这些运算符操作，不演示了



#### 5排序



```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int main (void) {
	string str("ghjkdshfdssadakgzxvgshjdtyjhdskg");
	sort (str.begin(), str.end());
	cout << str;
    // 输出：aadddddfgggghhhhjjjkkkssssstvxyz
    return 0;
}
```

按照字符从小到大进行排序



如果是string数组

```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int main (void) {
	string str[4];
	str[0] = "bb";
	str[1] = "abc";
	str[2] = "aac";
	str[3] = "aba";
	sort (str, str + 4);
	for (string i : str) {
		cout << i << '\n';
	}
    return 0;
}
```

输出如下：

```
aac
aba
abc
bb

```

是按照字典序对string数组进行排序

#### 6交换



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str1("abc");
	string str2("qwe");
	swap (str1, str2);
	cout << str1 + "\t" + str2 << '\n';
	str1.swap(str2);
	cout << str1 + "\t" + str2;
    return 0;
}
```

输出如下：

```
qwe     abc
abc     qwe
```



#### 7插入和删除



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdefg");
	string str2 ("123");
	str.insert(3, str2);
	cout << str;
    // 输出：abc123defg
    return 0;
}
```

从下标3开始插入一个str2字符串



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdefg");
	str.erase(3, 2);
	cout << str;
    // 输出：abcfg
    return 0;
}
```

从下标3开始删除两个字符串



insert和erase还有一堆重载

比如erase参数写迭代器区间



#### 8截取

使用substr可以截取字符串

可以说这个是字符串最常用的函数之一了



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdefg");
	string str2 = str.substr(1, 3);
    string str2 = str.substr(1);
	cout << str2;
    // 输出：bcd
    return 0;
}
```

str.substr(1, 3)表示从下标1开始往后截取3个字符

str.substr(1)表示从第一个字符开始截取到最后



#### 9寻找

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdabcdcba");
	cout << str.find("bcd");
    // 输出：1
    return 0;
}
```

str.find("bcd")返回从左到右第一次出现字符串"bcd"的下标，一个具体的值，不是迭代器，这与`find(str.begin(), str.end(),"bcd")`不同

如果没找到，会返回一个常量string::npos

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdabcdcba");
	cout << (str.find("123") == string::npos);
    // 输出：1
    return 0;
}
```



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdabcdcba");
	cout << str.find("bcd", 4);
    // 输出：5
    return 0;
}
```

str.find("bcd", 4)表示从下标4开始寻找字符串"bcd"第一次出现的位置



```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str ("abcdabcdcba");
	cout << str.rfind("bcd");
    // 输出：5
    return 0;
}
```

`str.rfind("bcd")`从右往左找字符串"bcd"的位置，返回该字符串首字母所在的下标

可以写第二个参数，表示从第二个参数位置开始从右往左找



和find有关的还有一堆函数

比如find_first_of、find_last_not_of等

想了解的自行查阅

##### size_t

```c++
size_t rootIndex = inOrder.find(root);
```

在 C++ 中，`size_t` 是一个无符号的整数类型，它通常被用来表示大小和索引。它的确切范围取决于平台，但是按照标准，它足以表示任何数组的大小。在 32 位系统上，`size_t` 通常是 32 位宽，在 64 位系统上，则通常是 64 位宽。

由于字符串的长度不能为负，使用 `size_t` 来存储长度和索引是合适的，因为这确保了值总是非负的。在 `find` 方法中，`size_t` 被用来表示找到的字符的索引位置。如果 `find` 方法没有找到指定的字符，它会返回一个特殊的值 `string::npos`，这也是 `size_t` 类型的，它的值通常是最大的 `size_t` 值，表示无效的索引。

##### string::npos

`string::npos` 是 C++ 标准库中 `string` 类的一个静态成员常量，它表示一个无效的或不存在的位置值。通常用于字符串操作中，表示未找到特定子串或字符的情况。

`string::npos` 的定义如下：

```cpp
static const size_type npos = -1;
```

`string::npos` 的实际值是 `string::size_type` 类型的最大值，通常被定义为 `-1`。因为 `string::size_type` 是一个无符号整数类型，所以不能直接使用 `-1` 来表示无效位置，而是使用 `string::npos` 来表示。

在字符串中进行查找操作时，如果没有找到指定的子串或字符，相关的函数通常会返回 `string::npos`。

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, world!";
    std::string subStr = "abc";

    size_t found = str.find(subStr);

    if (found != std::string::npos) {
        std::cout << "Substring found at position: " << found << std::endl;
    } else {
        std::cout << "Substring not found" << std::endl;
    }

    return 0;
}
```

输出结果为：

```
Substring not found
```

#### 10替换

在 C++ 中，你可以使用字符串的 `replace` 函数来替换字符串中的子串。`replace` 函数接受三个参数：替换的起始位置、替换的长度和替换的目标字符串。

以下是一个示例，演示如何使用 `replace` 函数替换字符串中的子串：

```c++
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, world!";
    std::string target = "world";
    std::string replacement = "OpenAI";
    size_t startPos = str.find(target);

    if (startPos != std::string::npos) {
        str.replace(startPos, target.length(), replacement);
        std::cout << "替换后的字符串: " << str << std::endl;
    } else {
        std::cout << "未找到要替换的子串" << std::endl;
    }

    return 0;
}
```



#### 11原始字符串

如果我们想在字符串存储特殊字符，比如双引号`"`和反斜杠`\`，那么就要用转义字符

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str = "\" \\n \\t \\";
	cout << str;
    // 输出：" \n \t \
	return 0;
}

```

可以说相当不美观（一般也不会这么写，但万一呢）

在C++11中，有这样的一种用法，使用`R"()"`去括住字符串，那么里面的字符串就不会转义

```c++
#include <iostream>
#include <string>
using namespace std;

int main (void) {
	string str = R"(" \n \t \)";
	cout << str;
    // 输出：" \n \t \
	return 0;
}

```

看起来貌似确实就直观多了



#### 12 数据类型转换(to_string，stoi，stoll，stof，stod)



C++11

to_string能将部分数据类型转化为字符串string



```c++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int main(void) {
	int a = 520;
	double b = 3.14;
	bool c = false;
	string str1 = to_string(a);
	string str2 = to_string(b);
	string str3 = to_string(c);
	cout << str1 << '\n' << str2 << '\n' << str3;
	return 0;
}
```

输出见下

```
520
3.140000
0
```



在C语言中，能用atoi将char数组转化为int类型

```C
#include <stdio.h>
#include <stdlib.h>

int main(void) {
	char str[10] = "123";
	int a = atoi(str);
	printf ("%d", a);
	return 0;
}
```

atoll转化为long long类型，atod转化为double类型 



同时，C++也有类似的将string字符串类型转为数字类型的函数

stoi将string类型转化为int

stoll将string类型转化为long long

stod将string类型转化为double

stold将string类型转化为long double

```C++
#include <iostream>
#include <string>
using namespace std;

int main(void) {
	string str1 = "123";
	string str2 = "3.14";
	int a = stoi(str1);
	long long b = stoi(str1);
	double c = stod(str2);
	long double d = stold(str2);
	printf ("%d %lld %.3lf %Lf\n", a, b, c, d);
	// 输出： 123 123 3.140 3.140000
	cout << a << ' ' << b << ' ' << c << ' ' << d;
	// 输出： 123 123 3.14 3.14 
	return 0;
}

```

甚至可以看出，cout不会把浮点数后面多余的0输出



#### 13memcpy

函数有三个参数，第一个是目标地址，第二个是源地址，第三个是数据长度。

使用memcpy函数时，需要注意：

- 数据长度（第三个参数）的单位是字节（1byte = 8bit）。
- 注意该函数有一个返回值，类型是void*，是一个指向destin的指针。



```cpp
char a[10] = "abcdefgh";
    unsigned n = 2;
    void * p = memcpy(a+3, a, n);
```

以上代码将从a开始的两个字节的数据（即’a’和’b’），复制到从a+3开始的内存（'d’所在的地址）。这样，'d’和’e’被替换。
执行结束之后，字符数组（字符串）a的内容变为"abcabfgh"，返回值p即为a的地址（p == a）。

#### 14memset

```c++
void memset(void *str, int ch, size_t n
```

将str中当前位置后面的n个字节用ch替换并返回s，也就是说这个函数的作用是将数字以单个字节逐个拷贝的方式放到指定的内存中
memset(a, 127, sizeof(a))
 127的二进制表示是01111111，在数组里存放的就是四个01111111，十进制数里是2139062143（小于int类型的范围）
`memset(a, 127, sizeof(a))`
  128二进制是10000000，四个10000000就是-2139062144，就是初始化为一个很小的数

memset是按字节赋值的，因此char类型的数组可以赋任意值。
因此memset的正规用法是用来初始化char类型的数组的，也就是说它只会接受0x00-0xFF的值。

因为0的二进制是32个0，-1的二进制是三十二个1，所以使用memset可以直接初始化0和-1。
如果要初始最大化，第一位是符号位为0，剩下为1，01111111化十六进制正好为`0x7f`，所以`memset(arr, 0x7f, sizeof())`就是初始最大化了。

但是这个数不能满足“无穷大加无穷大依然是无穷大”的性质，相加后它是一个很小的负数。
所以一般无穷大常量取值是`0x3f3f3f3f`。

`0x3f3f3f3f`十进制是1061109567，是10^9级别。

```c++
0x3f3f3f3f + 0x3f3f3f3f = 2122219134
```

没有超过32位int的范围，所以相加也满足“无穷大加无穷大以旧是无穷大”的性质
0x3f3f3f3f的每个字节都是0x3f，要把一段内存全部置为无穷大，只需要`memset(arr, 0x3f, sizeof(arr))`

其他memset赋值：

```c++
memset(arr,0x80,sizeof(arr)); //set int to -2139062144
memset(arr,0x7F,sizeof(arr)); //set double to 1.38242e+306
memset(arr,0xFE,sizeof(arr)); //set double to -5.31401e+303
```

作者：你算什么bug
链接：https://www.acwing.com/blog/content/16177/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





###  map库

#### 1.创建和存取数据

```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
    return 0;
}
```

map <int, int> mp就创建了一个int对应一个int的容器

这个对应关系可以不是int对应int，按照自己的需求来

map <string, bool> mp 这种其他对应关系也是可以的



一般管第一个数据称之为`key`，第二个数据称之为`value`

也就是映射，每个key映射一个value

往map里存取数据

```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
	
	mp.insert (pair<int, int> (4, 32));
	mp.insert (make_pair(2, 3));
	mp[5] = 11;
	
	for (pair<int, int> i : mp) {
		printf ("%d %d\n", i.first, i.second);
	}
    return 0;
}
```

输出如下：

```
2 3
4 32
5 11
```

最常用的还是像这种`mp[5] = 11`取存取数据



**使用迭代器或增强型for循环进行遍历时，会发现已经按照key从小到大排好序了**

​	

具体这玩意有啥用，等以后看题解别人用这个的时候就懂了

#### 2.size、empty、clear、count、erase、swap、find

map最重要的还是上面那部分，这节的这几个函数不一定能用上

所以就安排在一节里了



```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
	
	mp.insert (pair<int, int> (2, 3));
	mp.insert (make_pair(4, 32));
	mp[5] = 11;
	
	printf ("%d %d ", mp.size(), mp.count(5));
	mp.clear();
	printf ("%d", mp.empty());
    // 输出：3 1 1
    return 0;
}

```



mp.size()返回有效元素个数

mp.count(5)判断5这个key是否存在，存在返回1，没有则返回0

mp.clear()清空mp容器

mp.empty()判断mp容器是否为空，为空返回1，不为空返回0



```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
	mp[4] = 11;
	printf ("%d ", mp.count(4));
	mp.erase(4);
	printf ("%d", mp.count(4));
    // 输出：1 0
    return 0;
}

```

mp.erase(4)根据4这个key去删除一对元素



```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp1, mp2;
	mp1[4] = 17;
    mp2[4] = 71;
	printf ("%d %d\n", mp1[4], mp2[4]);
    // 输出：17 71
	mp1.swap (mp2);
	printf ("%d %d", mp1[4], mp2[4]);
    // 输出：71 17
    return 0;
}

```

mp1.swap (mp2)与同类型交换



```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
	mp[4] = 17;
	mp[1] = 2;
	mp[3] = 4;
	map <int, int> :: iterator it = mp.find(3);
	for (; it != mp.end(); ++it) {
		printf ("%d %d\n", it->first, it->second);
	}
    return 0;
}

```

mp.find(3)返回key为3的迭代器，如果不存在返回mp.end()

#### 3.lower_bound 和 upper_bound



使用二分去查找键

```c++
#include <iostream>
#include <map>
using namespace std;

int main (void) {
	map <int, int> mp;
	

	mp[1] = 2;
	mp[3] = 4;
    mp[4] = 17;
	
	map <int, int> :: iterator it1 = mp.lower_bound(3);
	map <int, int> :: iterator it2 = mp.upper_bound(3);
	printf ("%d %d\n", it1->first, it1->second);
    // 输出：3 4
	printf ("%d %d", it2->first, it2->second);
    // 输出：4 17
    return 0;
}

```

mp.lower_bound(3)返回第一个大于等于key的迭代器

mp.upper_bound(3)返回第一个大于key的迭代器



下面讲的unordered_map肯定不支持这两个函数



#### 4.unordered_map



unordered_map是C++11标准里的新头文件，可以创建unordered_map类型

unordered_map是一个无序的map

而前两节说的map，是有序的



这里的无序是指：按照插入顺序的进行存储

而那个有序是指：会按照key的大小排序

主要在遍历map时才能体现出这个的差异



```c++
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main (void) {
	map <int, int> mp1;
	unordered_map <int, int> mp2;
	
	mp1[4] = 17;
	mp1[1] = 2;
	mp1[3] = 4;
	
	mp2[4] = 17;
	mp2[1] = 2;
	mp2[3] = 4;
	
	for (pair<int, int> i : mp1) {
		printf ("%d %d\n", i.first, i.second);
	}
	putchar ('\n');
	for (pair<int, int> i : mp2) {
		printf ("%d %d\n", i.first, i.second);
	}
    return 0;
}

```

输出如下：

```
1 2
3 4
4 17

3 4
1 2
4 17
```



**如果只是单纯按照key去查询value的话，使用unordered_map的效率要高**

**map为了有序内部使用了红黑树，效率低一些**

**所以如果不准备用遍历map容器，建议都用unordered_map**



还有一种map是multimap，是允许key重复的map，这个我觉得一般用不上，感兴趣的自行学习



### stack库

栈具有“**后进先出**”的特点。元素只能从堆栈顶部进行添加（称为压入，push）和移除（称为弹出，pop）操作。最后一个压入堆栈的元素是第一个弹出堆栈的元素。



```c++
#include <stack>
using namespace std;

int main (void) {
	stack <int> st;
	
    return 0;
}
```

创建一个stack



```c++
#include <cstdio>
#include <stack>
using namespace std;

int main (void) {
	stack <int> st, st2;
	st.push(3);
	st.push(5);
	printf ("%d\n", st.top()); // 输出：5
	st.pop();
	printf ("%d %d\n", st.size(), st.empty()); // 输出：1 0
	st2.swap(st);
	printf ("%d\n", st2.top()); // 输出：3
    return 0;
}
```

st.push(3)     把3压栈

st.top()          返回栈顶元素（即最后那个元素）

st.pop()		 弹出一个**栈顶**元素

st.size()		 返回栈当前有几个元素

st.empty()	 判断当前栈是否为空，为空返回1，不为空返回0

st2.swap(st)  交换栈(C++11标准)



### queue库

#### （1）队列

队列具有**先进先出**的特点。元素只能从队列的一端进行添加（称为入队，enqueue）操作，从另一端进行移除（称为出队，dequeue）操作。最先入队的元素是最先出队的元素。

```c++
#include <queue>
using namespace std;

int main (void) {
	queue <int> q;
    
    return 0;
}
```

创建队列



```c++
#include <cstdio>
#include <queue>
using namespace std;

int main (void) {
	queue <int> q, q2;
	q.push(3);
	q.push(1);
	q.push(5);
	printf ("%d %d\n", q.front(), q.back()); // 输出：3 5
	q.pop();
	printf ("%d %d\n", q.size(), q.empty()); // 输出：2 0
	q2.swap(q);
	printf ("%d %d\n", q2.front(), q2.back()); // 输出：1 5
    return 0;
}

```

q.push(3)	将3入队

q.front()	  返回队首元素

q.back()       返回队尾元素

q.pop()		 将一个**队首**元素出队

q.size()		 返回队列中有多少元素

q.empty()	 判断当前队列是否为空，为空返回1，不为空返回0

q2.swap(q)   交换队列(C++11标准)





#### （2）deque



双端队列，可以从两端入队出队，头文件是deque(实际上queue包含deque)

比vector功能多，但效率比vector慢一些

所以vector拥有的功能这里就不介绍了

```c++
#include <deque>
using namespace std;

int main (void) {
	deque <int> q;
    
    return 0;
}
```

创建双端队列



```c++
#include <cstdio>
#include <deque>
using namespace std;

int main (void) {
	deque <int> q, q2;
	
	q.push_back(3);
	q.push_back(1);
	q.push_front(5);

	printf ("%d %d\n", q.front(), q.back()); // 输出：5 1
	q.pop_back();
	q.pop_front();
	printf ("%d %d\n", q.size(), q.empty()); // 输出：1 0
	q2.swap(q);
	printf ("%d %d\n", q2.front(), q2.back()); // 输出：3 3
    return 0;
}

```

q.push_back(3)	将3入队尾

q.push_front(5)    将5入队首

q.front()	  			返回队首元素

q.back()       			返回队尾元素

q.pop_front()		  将一个队首元素出队

q.pop_back()		   将一个队尾元素出队

q.size()		 			返回队列中有多少元素

q.empty()	 			判断当前队列是否为空，为空返回1，不为空返回0

q2.swap(q)   			交换队列



#### (3)priority_queue(堆)



优先队列，存入的时候会**自动排好序**，默认**降序**，底层实现是用**堆**实现的



```c++
#include <queue>
using namespace std;

int main (void) {
	priority_queue <int> q;
    
    return 0;
}
```

创建优先队列



```c++
#include <cstdio>
#include <queue>
using namespace std;

int main (void) {
	priority_queue <int> q, q2;
	q.push(3);
	q.push(1);
	q.push(5);
	printf ("%d\n", q.top());
	q.pop();
	printf ("%d %d\n", q.size(), q.empty());
	q2.swap(q);
	printf ("%d\n", q2.top());
    return 0;
}

```

```cpp
q.push(3)		//将3入队
q.top()			// 返回队首元素
q.size()			 返回队列中有几个元素
q.empty()		 判断当前队列是否为空，为空返回1，不为空返回0
q2.swap(q)	  交换队列(C++11标准)
```



要想升序，这么创建

```c++
#include <queue>
using namespace std;

int main (void) {
	priority_queue <int, vector<int>, greater<int> > q;
    
    return 0;
}
```

注意**不要让两个大于号`>`连在一起，否则有可能会识别成右移运算符报错**

第一个参数写数据类型

第二个参数写容器类型

第三个参数写仿函数，即像函数的类

所以以后如果要自定义比较规则，就得先学学仿函数

总之这三个参数背下来就行



```c++
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;

int main (void) {
	priority_queue <int, vector<int>, greater<int> > q, q2;
	q.push(3);
	q.push(1);
	q.push(5);
	printf ("%d\n", q.top()); // 输出：1
	q.pop();
	printf ("%d %d\n", q.size(), q.empty()); // 输出：2 0
	q2.swap(q);
	printf ("%d\n", q2.top()); // 输出：3
    return 0;
}

```



仿函数这么写

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;

#define PP pair<int,int>

struct cmp {
    //重写仿函数
    bool operator()(PP a, PP b)
    {
        return a.first > b.first;
    }

};

int main()
{
    priority_queue<PP, vector<PP>, cmp> q;

    q.push(make_pair(4, 6));
    q.push(make_pair(9, 4));
    q.push(make_pair(6, 1));
    while (!q.empty())
    {
        printf("%d %d\n", q.top().first, q.top().second);
        q.pop();
    }

    return 0;
}


```



### 堆 （Heap）

#### 堆的概念

前面介绍的优先级队列在JDK1.8中其底层使用了堆的数据结构，而堆实际就是在完全二叉树的基础之上进行了一些元素的调整。

如果有一个 关键码的集合 K = {k0 ， k1 ， k2 ， … ， kn-1} ，把它的所有元素 按完全二叉树的顺序存储方式存储 在一 个一维数组中 ，并满足： Ki <= K2i+1 且 Ki<= K2i+2 (Ki >= K2i+1 且 Ki >=K2i+2) i = 0 ， 1 ， 2… ，则 称为小堆 ( 或大堆) 。（即双亲比孩子的数值小(大)——小(大)堆）将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

#### 堆的性质

- 堆中某个节点的值总是不大于或不小于其父节点的值；
- 堆总是一棵完全二叉树。



下面来看一下堆的可视化操作
堆的可视化操作https://visualgo.net/zh/heap

#### 堆的创建

##### 1、堆向下调整

对于集合 { 27,15,19,18,28,34,65,49,25,37 } 中的数据，如果将其创建成堆呢？

仔细观察上图后发现： 根节点的左右子树已经完全满足堆的性质，因此只需将根节点向下调整好即可 。
向下过程 ( 以小堆为例 ) ：

- 让 parent 标记需要调整的节点， child 标记 parent 的左孩子 ( 注意： parent 如果有孩子一定先是有左孩子 )
- 如果 parent 的左孩子存在，即 :child < size ， 进行以下操作，直到 parent 的左孩子不存在
  parent右孩子是否存在，存在找到左右孩子中最小的孩子，让child进行标记
  将parent与较小的孩子child比较，如果：parent小于较小的孩子child，调整结束。否则：交换parent与较小的孩子child，交换完成之后，parent中大的元素向下移动，可能导致子树不满足对的性质，因此需要继续向下调整，即parent = child；child = parent*2+1; 然后继续2。

```c++
public void shiftDown(int[] array, int parent) {
    // child先标记parent的左孩子，因为parent可能右左没有右
    int child = 2 * parent + 1;
    int size = array.length;
    while (child < size) {
           // 如果右孩子存在，找到左右孩子中较小的孩子,用child进行标记
           if(child+1 < size && array[child+1] < array[child]){
                 child += 1;
    	   }

           // 如果双亲比其最小的孩子还小，说明该结构已经满足堆的特性了
           if (array[parent] <= array[child]) {
                   break;
           }else{
               // 将双亲与较小的孩子交换
               int t = array[parent];
               array[parent] = array[child];
               array[child] = t;

               // parent中大的元素往下移动，可能会造成子树不满足堆的性质，因此需要继续向下调整
               parent = child;
               child = parent * 2 + 1;
           }
	}

}
```

注意：在调整以 parent 为根的二叉树时，必须要满足 parent 的左子树和右子树已经是堆了才可以向下调整。
时间复杂度分析：
最坏的情况即图示的情况，从根一路比较到叶子，比较的次数为完全二叉树的高度，即时间复杂度为O(log₂N)

##### 2、堆的创建

那对于普通的序列 { 1,5,3,8,7,6 } ，即根节点的左右子树不满足堆的特性，又该如何调整呢？

```c++
public static void createHeap(int[] array) {
    // 找倒数第一个非叶子节点，从该节点位置开始往前一直到根节点，遇到一个节点，应用向下调整
    for(int root = (array.length-2)/2; root >= 0; root--){
            shiftDown(array, array.length, root);
    }
}
```

##### 3、建堆的时间复杂度

因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明 ( 时间复杂度本来看的就是近似值，多几个节点不影响最终结果) ：

因此：建堆的时间复杂度为O(N) 

#### 堆的插入和删除

##### 1、堆的插入

堆的插入总共需要两个步骤：

- 先将元素放入到底层空间中(注意：空间不够时需要扩容)
- 将最后新插入的节点向上调整，直到满足堆的性质

```c++
public void shiftUp(int child) {
    // 找到child的双亲
    int parent = (child - 1) / 2;
```




```c++
while (child > 0) {
// 如果双亲比孩子大，parent满足堆的性质，调整结束
      if (array[parent] > array[child]) {
          break;
      }else{
      // 将双亲与孩子节点进行交换
      int t = array[parent];
      array[parent] = array[child];
      array[child] = t;
 
      // 小的元素向下移动，可能到值子树不满足对的性质，因此需要继续向上调增
      child = parent;
      parent = (child - 1) / 2;
      }
}
```

##### 2、堆的删除

堆的删除一定删除的是堆顶元素。
堆的删除步骤如下：

- 将堆顶元素对堆中最后一个元素交换
- 将堆中有效数据个数减少一个
- 对堆顶元素进行向下调整

```c++
public static void shiftDown(int[] array, int size, int parent){
        int child = parent*2+1;
 
        while(child < size){
            // 找左右孩子中较大的孩子
            if(child+1 < size && array[child+1] > array[child]){
                child += 1;
            }
 
            // 双亲小于交大的孩子
            if(array[parent] < array[child]){
                swap(array, parent, child);
                parent = child;
                child = parent*2+1;
            }else{
                return;
            }
        }
}
```

#### 堆的应用

##### 1、优先级队列的实现

用堆作为底层结构 封装优先级队列

```c++
public class MyPriorityQueue {
    Integer[] array;
    int size;   // 有效元素的个数
 
    public MyPriorityQueue(){
        array = new Integer[11];
        size = 0;
    }
 
    public MyPriorityQueue(int initCapacity){
        if(initCapacity < 1){
            throw new IllegalArgumentException("初始容量小于1");
        }
 
        array = new Integer[initCapacity];
        size = 0;
    }
 
    public MyPriorityQueue(Integer[] arr){
        // 1. 将arr中的元素拷贝到数组中
        array = new Integer[arr.length];
        for(int i = 0; i < arr.length; ++i){
            array[i] = arr[i];
        }
        size = arr.length;
 
        // 2. 找当前完全二叉树中倒数第一个叶子节点
        //    注意：倒数第一个叶子节点刚好是最后一个节点的双亲
        //    最后一个节点的编号size-1  倒数第一个非叶子节点的下标为(size-1-1)/2
        int lastLeafParent = (size-2)/2;
 
        // 3. 从倒数第一个叶子节点位置开始，一直到根节点的位置，使用向下调整
        for(int root = lastLeafParent; root >= 0; root--){
            shiftDown(root);
        }
    }
 
    boolean offer(Integer e){
        if(e == null){
            throw new NullPointerException("插入时候元素为null");
        }
 
        ensureCapacity();
 
        array[size++] = e;
 
        // 注意：当新元素插入之后，可能会破坏对的性质---需要向上调整
        shiftUp(size-1);
        return true;
    }
 
    // 将堆顶的元素删除掉
    public Integer poll(){
        if(isEmpty()){
            return null;
        }
 
        Integer ret = array[0];
 
        // 1. 将堆顶元素与堆中最后一个元素交换
        swap(0, size-1);
 
        // 2. 将堆中有效元素个数减少一个
        size--;  // size -= 1;
 
        // 3. 将堆顶元素往下调整到合适位置
        shiftDown(0);
        return ret;
    }
 
    public int size(){
        return size;
    }
 
    public boolean isEmpty(){
        return size == 0;
    }
 
    public void clear(){
        size = 0;
    }
 
    // 功能：调整以parent为根的二叉树
    //    前提：必须要保证parent的左右子树已经满足堆的特性
    // 时间复杂度：O(logN)
    private void shiftDown(int parent){
        // 默认让child先标记左孩子---因为：parent可能有左没有右
        int child = parent*2 + 1;
 
        // while循环条件可以保证：parent的左孩子一定存在
        //       但是不能保证parent的右孩子是否存在
        while(child < size){
            // 1. 找到左右孩子中较小的孩子
            if(child+1 < size && array[child+1] < array[child]){
                child += 1;
            }
 
            // 2. 较小的孩子已经找到了
            //    检测双亲和孩子间是否满足堆的特性
            if(array[parent] > array[child]){
                swap(parent, child);
 
                // 大的双亲往下走了，可能会导致子树又不满足堆的特性
                // 因此需要继续往下调整
                parent = child;
                child = parent*2 + 1;
            }else{
                // 以parent为根的二叉树已经是堆了
                return;
            }
        }
    }
 
    private void shiftUp(int child){
        int parent = (child-1)/2;
 
        while(child != 0){
            if(array[child] < array[parent]){
                swap(child, parent);
                child = parent;
                parent = (child-1)/2;
            }else{
                return;
            }
        }
    }
 
    private void ensureCapacity(){
        if(array.length == size){
            int newCapacity = array.length*2;
            array = Arrays.copyOf(array, newCapacity);
        }
    }
 
    // 注意：left和right是数组的下标
    private void swap(int left, int right){
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }
```

##### 2、堆排序

堆排序即利用堆的思想来进行排序，总共分为两个步骤：

- 建堆

  升序：建大堆
  降序：建小堆

- 利用堆删除思想来进行排序

  建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序

```c++
public static void swap(int[] array, int left, int right){
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }
 
    public static void shiftDown(int[] array, int size, int parent){
        int child = parent*2+1;
 
        while(child < size){
            // 找左右孩子中较大的孩子
            if(child+1 < size && array[child+1] > array[child]){
                child += 1;
            }
 
            // 双亲小于交大的孩子
            if(array[parent] < array[child]){
                swap(array, parent, child);
                parent = child;
                child = parent*2+1;
            }else{
                return;
            }
        }
    }
 
    // 假设：升序
    public static void heapSort(int[] array){
        // 1. 建堆----升序：大堆    降序：小堆---向下调整
        for(int root = (array.length-2)/2; root >= 0; root--){
            shiftDown(array, array.length, root);
        }
 
 
        // 2. 利用堆删除的思想来排序---向下调整
        int end = array.length-1;   // end标记最后一个元素
        while(end != 0){
            swap(array,0,end);
            shiftDown(array, end,0);
            end--;
        }
    }
```

 

###### 3、Top-k问题 

TOP-K 问题：即求数据结合中前 K 个最大的元素或者最小的元素，一般情况下数据量都比较大 。
对于 Top-K 问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了 ( 可能数据都不能一下子全部加载到内存中) 。最佳的方式就是用堆来解决，基本思路如下：

- 用数据集合中前 K 个元素来建堆
  前k个最大的元素，则建小堆
  前k个最小的元素，则建大堆
- 用剩余的 N-K 个元素依次与堆顶元素来比较，不满足则替换堆顶元素
  将剩余 N-K 个元素依次与堆顶元素比完之后，堆中剩余的 K 个元素就是所求的前 K 个最小或者最大的元素。
  Top-k问题

```c++
class Solution {
    public int[] smallestK(int[] arr, int k) {
        int[] vec = new int[k];
        if (k == 0) { // 排除 0 的情况
            return vec;
        }
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() {
            public int compare(Integer num1, Integer num2) {
                return num2 - num1;
            }
        });
        for (int i = 0; i < k; ++i) {
            queue.offer(arr[i]);
        }
        for (int i = k; i < arr.length; ++i) {
            if (queue.peek() > arr[i]) {
                queue.poll();
                queue.offer(arr[i]);
            }
        }
        for (int i = 0; i < k; ++i) {
            vec[i] = queue.poll();
        }
        return vec;
    }
}
```

复杂度分析

时间复杂度：O(nlog k)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。

空间复杂度：O(k)，因为大根堆里最多 k 个数
————————————————
版权声明：本文为CSDN博主「Owen_Xp」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_51601105/article/details/121286334

### list库

#### list的简介（双链表）

list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代，**底层是双链表**，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。

- list与forward_list非常相似：主要不同在于forward_list是单链表，只能单方向迭代。
- 与其他的序列式容器相比(array，vector，deque)，list在任意位置进行插入、移除元素的执行效率更好。
- 与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置。
- list还需要一些额外的空间，以保存每个节点的相关联信息。

#### list的使用

##### list 的构造

```c++
list<int> lt1;	// 构造int类型的空容器
list<int> lt2(3, 2);  // 构造含有3个2的int类型容器
list<int> lt3(lt2);  // 拷贝构造lt2
string s("hello");
list<char> lt4(s.begin(), s.end());  // 利用迭代器构造
```



##### list 插入和删除数据

###### push_front和pop_front

```c++
int main()
{
	list<int> lt;
	// 头插数据
	lt.push_front(1);
	lt.push_front(2);
	lt.push_front(3);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	// 头删数据
	lt.pop_front();
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	return 0;
}
```



###### push_back和pop_back

```c++
int main()
{
	list<int> lt;
	// 尾插数据
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	// 尾删数据
	lt.pop_back();
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	return 0;
}
```



###### insert

- 在指定位置插入一个或者多个数据。
- 在指定位置插入一段迭代器区间（左闭右开）。

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	list<int>::iterator pos = find(lt.begin(), lt.end(), 2);
	lt.insert(pos, 4); //在2的位置插入9
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;

	pos = find(lt.begin(), lt.end(), 3);
	lt.insert(pos, 3, 5); //在3的位置插入3个5
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;

	vector<int> v{ 6, 6 };
	pos = find(lt.begin(), lt.end(), 1);
	lt.insert(pos, v.begin(), v.end()); //在1的位置插入2个6
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	return 0;

}
```



###### erase

erase有两种删除方式

- 删除指定位置数据
- 删除指定迭代器区间中的数据。

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	list<int>::iterator pos = find(lt.begin(), lt.end(), 2);
	lt.erase(pos); // 删除2
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;

	pos = find(lt.begin(), lt.end(), 3);
	lt.erase(pos, lt.end()); //删除3及其之后的元素
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	return 0;

}
```

##### list 迭代器的使用

注意：

- begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动
- rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动

```c++
int main()
{
	string s("hello");
	list<char> lt(s.begin(), s.end());
	//正向迭代器遍历容器
	list<char>::iterator it = lt.begin();
	while (it != lt.end())
	{
		cout << *it << " ";
		it++;
	}
	cout << endl;

	//反向迭代器遍历容器
	list<char>::reverse_iterator rit = lt.rbegin();
	while (rit != lt.rend())
	{
		cout << *rit << " ";
		rit++;
	}
	cout << endl;
	return 0;

}
```



#### list 获取数据

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(4);
	cout << lt.front() << endl;
	cout << lt.back() << endl;
	return 0;
}
```




#### list 容量大小

```
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	cout << lt.size() << endl;
	cout << lt.empty() << endl;
}
```




#### list 相关操作函数

###### swap

swap用于交换两个容器的内容。

```
int main()
{
	list<int> lt1(3, 2);
	list<int> lt2(2, 3);
	lt1.swap(lt2); //交换两个容器的内容
	return 0;
}
```




###### clear

clear用于清空容器，清空后容器的size为0。

```
int main()
{
	list<int> lt(3, 2);
	lt.clear();
	return 0;
}
```



##### sort

sort可以将容器当中的数据排序（升序）。

```c++
int main()
{
	list<int> lt;
	lt.push_back(2);
	lt.push_back(1);
	lt.push_back(4);
	lt.push_back(3);
	cout << "排序前:";
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;

	lt.sort();
	cout << "排序后:";
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;

}
```



##### resize

resize操作方式有两种

- 当所给值大于当前的size时，将size扩大到该值，扩大的数据为第二个所给值，若未给出，则默认为容器所存储类型的默认构造函数所构造出来的值。
- 当所给值小于当前的size时，将size缩小到该值。

```c++
int main()
{
	list<int> lt(3, 3);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	lt.resize(5, 4); //将size扩大为5，扩大的值为4
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	lt.resize(2); //将size缩小为2
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	return 0;
}
```



##### remove

remove可以移除指定元素。

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(2);
	lt.push_back(3);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	lt.remove(2); // 删除容器当中值为2的元素
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl; 
	return 0;
}
```




##### unique

unique的作用是去除连续重复的元素（如果要去除所有重复的元素需要先排序）

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(3);
	lt.push_back(2);
	lt.push_back(3);
	lt.push_back(2);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	lt.unique();// 去除连续重复的元素
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	lt.sort();// 排序
	lt.unique();
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	return 0;
}


```

##### reverse

reverse可以将容器当中元素的进行逆置。

```c++
int main()
{
	list<int> lt;
	lt.push_back(1);
	lt.push_back(2);
	lt.push_back(3);
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	lt.reverse();// 逆置
	for (auto e : lt)
	{
		cout << e << " ";
	}
	cout << endl;
	return 0;
}
```

————————————————
版权声明：本文为CSDN博主「小倪同学 -_-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_56663697/article/details/121308759

#### 对比

- 如果你需要频繁插入和删除数据，并且希望编程简单一些，标准库的 list 容器是一个不错的选择。
- 如果你需要一个尽可能节省空间的链表，并且不介意数组大小固定的限制，那么数组模拟链表是一个合适的选择。
- 如果你需要最大程度地控制数据结构的每一个细节，并且不担心内存管理的复杂性，使用结构体模拟链表会是最灵活的方法。



#### new

##### 定义

在C++中，`new` 是一个用于在堆上动态分配内存的运算符。它允许在程序运行时创建和销毁对象，并返回一个指向该对象的指针。

##### 使用

使用 `new` 运算符分配内存时，需要指定要分配的对象的类型，并返回一个指向该对象的指针。例如，可以使用以下方式创建一个 `int` 对象并返回指向它的指针：

```c++
int* p = new int;
```

在上述示例中，`new int` 分配了足够的内存来存储一个整数，并返回一个指向该内存的指针。可以通过 `p` 来访问和操作这个整数。当不再需要这块内存时，应使用 `delete` 运算符释放它：

```c++
delete p;
```

`delete` 运算符用于释放通过 `new` 运算符分配的内存，并调用对象的析构函数进行清理。这样可以防止内存泄漏并释放不再需要的资源。

##### 注意

需要注意的是，`new` 运算符分配的内存需要手动释放，否则会导致内存泄漏。在使用 `new` 和 `delete` 时，应始终成对使用，并遵循正确的内存管理原则。此外，C++ 还提供了更安全和方便的内存管理方式，如智能指针（例如 `std::shared_ptr` 和 `std::unique_ptr`），推荐在可行的情况下使用它们来管理动态内存分配。

##### 和malloc异同

- `new`是[操作符](https://so.csdn.net/so/search?q=操作符&spm=1001.2101.3001.7020)，malloc是函数；

- `new`开辟内存失败[抛出异常](https://so.csdn.net/so/search?q=抛出异常&spm=1001.2101.3001.7020)，malloc申请内存失败返回`NULL`；

- `new`开辟的内存大小不需要指定，`malloc`需要指定；

- `new`开辟的内存的类型会自动推导，不需要强转，malloc需要强转；

- 实现原理：

  `new`会先调用`operator new`函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用`operator delete`函数释放内存（通常底层使用free实现）。

  ```c++
  new->malloc->构造函数->delete->析构函数->free;
  ```
  
  `malloc/free`是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。所以`malloc`没有初始化功能，需要用户自己初始化。（只能申请内存，不能初始化）
  ————————————————
  版权声明：本文为CSDN博主「猿饵块」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/m0_60274660/article/details/127444738

### set库

#### 基本信息

set就是集合，底层是红黑树，存入时会自动去重和排序，默认是升序

访问元素的时间复杂度是O ( log ⁡ 2 n ) O(\log_2n)O(log 

- 所有元素都会在插入时**自动被排序**
- set/multiset属于**关联式容器**，底层结构是用**二叉树**实现
- set**不允许**容器中有**重复**的元素
- multiset**允许**容器中有**重复**的元素

#### 内容

在c++中，set的头文件是``#include<set>``

set具有迭代器``set<int>::iterator i` 定义一个迭代器,名为i 可以把迭代器理解为C语言的指针

#### set常用操作

```c++
set<int> q;     //以int型为例 默认按键值升序
multiset<int> q;
set<int> s1(s); //拷贝构造
set<int,greater<int>> p;  //降序构造 

bool myCompare(int v1,int v2)const {
		return v1 > v2;
	}
set<int,myCompare> s1;//以myCompare为排序准则

set<int> s2;
s2 = s1;//赋值

s1.swap(s2);	//交换
q.insert(x);	//将x插入q中

//set插入数据的同时会返回插入的bool结果，表示插入是否成功
//multiset不会检测数据，直接返回一个迭代器，因此可以插入重复数据

q.erase(x);		//删除q中的x元素,返回0或1,0表示set中不存在x
q.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。
q.erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
q.clear();		//清空q

q.empty();		//判断q是否为空，若是返回1，否则返回0
q.count(x);     //统计x元素个数
q.size();		//返回q中元素的个数
q.find(x);		//在q中查找x，返回x的迭代器，若x不存在，则返回指向q尾部的迭代器即 q.end()
q.lower_bound(x); //返回一个迭代器，指向第一个键值不小于x的元素
q.upper_bound(x); //返回一个迭代器，指向第一个键值大于x的元素

q.rend();		  //返回第一个元素的的前一个元素迭代器

q.begin();		  //返回指向q中第一个元素的迭代器
q.end();		 //返回指向q最后一个元素下一个位置的迭代器
q.rbegin();		 //返回最后一个元素
```



#### set单元素应用

```c++
#include<iostream>
#include<set>
using namespace std;
int main()
{
	set<int> q;   //默认按升序排列 
	q.insert(5);
	q.insert(5);
	q.insert(5);
	cout << "q.size " << q.size() << endl;   //输出 1 ,在set插入中相同元素只会存在一个


	q.clear(); //清空set
	cout << "q.size " << q.size() << "\n\n";

	q.insert(4);
	q.insert(4);
	q.insert(3);
	q.insert(3);
	q.insert(2);
	q.insert(1);

	cout << "lower_bound " << *q.lower_bound(3) << endl;  //返回3 
	cout << "upper_bound " << *q.upper_bound(3) << "\n\n";  //返回4 

	set<int>::iterator i;
	for (i = q.begin(); i != q.end(); i++)   //set的遍历 
		cout << *i << " ";				   //输出1 2 3 4，可见自动按键值排序 
	cout << endl;

	q.erase(4);  //删除q中的 4 

	for (i = q.begin(); i != q.end(); i++)  //再次遍历set 只输出 1 2 3 
		cout << *i << " ";
	cout << "\n\n";

	set<int, greater<int>> p;  //降序排列 
	p.insert(1);
	p.insert(2);
	p.insert(3);
	p.insert(4);
	p.insert(5);
	for (i = p.begin(); i != p.end(); i++)
		cout << *i << " ";
	cout << endl;

	return 0;

}
```

————————————————————————————————————————————————
		版权声明：本文为CSDN博主「Jemery-an」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/weixin_52341477/article/details/119248919

#### 迭代器

多重集合`multiset` 是一个允许重复元素的有序容器，它的元素按照特定的顺序存储，通常是按照其值的升序。因此不可以像处理向量（`vector`）那样简单地使用迭代器与整数值进行减法或加法运算。因为 **`multiset` 的内部结构通常是一个平衡二叉树**，其迭代器并不支持随机访问，所以 `it - a.begin()` 和 `a.begin() + 3` 这样的操作是不合法的。

当我们访问集合中第x个元素时，我们可以使用函数`advance`函数，其原型如下：

```c++
template <class InputIterator, class Distance>
void advance (InputIterator& it, Distance n);
```

其中，`it` 是要移动的迭代器的引用，`n` 是要前进（或后退，如果 `n` 为负数且迭代器为双向或随机访问迭代器）的位置数。



例如，对一个指向 `multiset` 的迭代器，并想要移动它到第3个位置

```c++
std::multiset<int>::iterator it = myMultiset.begin();
std::advance(it, 2); // 移动迭代器到第三个元素（从0开始计数）
```

如果迭代器是一个双向迭代器（如 `std::list` 或 `std::set` 的迭代器），`std::advance` 会通过重复增加或减少迭代器来移动它。如果迭代器是一个随机访问迭代器（如 `std::vector` 或 `std::deque` 的迭代器），`std::advance` 则可以直接通过加法或减法来计算新位置。

如果试图将迭代器移动到 `multiset` 的末尾之后，或者是在 `begin()` 之前，程序可能会出错。



如果想输出查找到的元素在数组（或向量）中的位置（即它是第几个元素），可以使用 `std::distance` 函数计算从向量开始迭代器到找到的元素的迭代器之间的距离。这个距离加1就给出了元素的位置（因为通常我们从1开始计数，而不是从0）

```c++
distance(a.begin(), it) + 1
```



### ctype库

#### 1.isdigit

**isdigit**是C++中的一个函数，用于检查字符是否是一个十进制数字。

`isdigit`函数接受一个`int`类型的参数，它的值必须是一个有效的字符或者EOF（End of File）。函数返回一个非零值，如果参数是一个十进制数字字符（'0'-'9'）；否则返回0。

以下是一个示例代码，演示了如何使用`isdigit`函数：

```cpp
#include <iostream>
#include <cctype>

int main() {
    char ch = '7';

    if (isdigit(ch)) {
        std::cout << "The character is a digit." << std::endl;
    } else {
        std::cout << "The character is not a digit." << std::endl;
    }

    return 0;
}
```

#### 2.isalpha

在C++中，可以使用`isalpha`函数来检查一个字符是否是字母。

函数原型如下：

```cpp
#include <cctype>

int isalpha(int c);
```

`isalpha`函数接受一个`int`类型的参数，它的值必须是一个有效的字符或者EOF（End of File）。函数返回一个非零值，如果参数是一个字母字符（A-Z或a-z）；否则返回0。

以下是一个示例代码，演示了如何使用`isalpha`函数：

```cpp
#include <iostream>
#include <cctype>

int main() {
    char ch = 'A';

    if (isalpha(ch)) {
        std::cout << "The character is an alphabet." << std::endl;
    } else {
        std::cout << "The character is not an alphabet." << std::endl;
    }

    return 0;
}
```

在上述示例中，我们将字符 `'A'` 传递给 `isalpha` 函数进行检查。由于 `'A'` 是一个字母字符，因此 `isalpha` 函数返回非零值，输出 "The character is an alphabet."。

#### 3.其他函数

`isalnum(int c)`：检查字符是否是字母或数字。

`isupper(int c)`：检查字符是否是大写字母。

`islower(int c)`：检查字符是否是小写字母。

`isspace(int c)`：检查字符是否是空白字符（空格、制表符、换行符等）。

`toupper(int c)`：将字符转换为大写字母。

`tolower(int c)`：将字符转换为小写字母。

### pair

#### 1.使用

1.在 utility头文件里

2.用来存储一对数据

3.创建：`pair<数据类型1, 数据类型2> 变量名`

#### 2.直接使用

```c++
#include <cstdio>
#include <utility>
using namespace std;

int main (void) {
	pair <int, int> p;
	p.first = 3;
	p.second = 4;
	printf ("%d %d", p.first, p.second);
    // 输出：3 4
    return 0;
}
```

p.first是访问第一个数据

p.second是访问第二个数据

#### 3.构造函数

可以直接把值赋好

```c++
#include <cstdio>
#include <utility>
using namespace std;

int main (void) {
	pair <int, int> p(3, 4);
	printf ("%d %d", p.first, p.second);
    // 输出：3 4
    return 0;
}
```

#### 4.创建数组

pair也可以去创建数组

```c++
#include <cstdio>
#include <utility>
using namespace std;

int main (void) {
	pair <int, int> p[5];
	for (int i = 0; i < 5; ++i) {
		p[i].first = i;
		p[i].second = i * 2;
	}
	for (int i = 0; i < 5; ++i) {
		printf ("%d %d\n", p[i].first, p[i].second);
	}
    return 0;
}

```

输出如下：

```
0 0
1 2
2 4
3 6
4 8

```

#### 5.用sort排序

```c++
#include <cstdio>
#include <algorithm>//使用见下一章
using namespace std;

int main (void) {
	pair <int, int> p[5];
	
	p[0].first = 3; p[0].second = 3;
    p[1].first = 2; p[1].second = 3;
	p[2].first = 3; p[2].second = 1;
	p[3].first = 3; p[3].second = 4;
	p[4].first = 4; p[4].second = 1;
	
	sort (p, p+5);
	
	for (int i = 0; i < 5; ++i) {
		printf ("%d %d\n", p[i].first, p[i].second);
	}
    return 0;
}
```

输出如下：

```
2 3
3 1
3 3
3 4
4 1

```

可以看出，sort会**优先按照first从小到大排序，first相等时，再按照second从小到大排序**

### class

类，暂时可以当成结构体来用

#### 直接定义

```c++
#include <cstdio>

struct test {
	int num1;
	int num2;
};

int main (void) {
	test a;//不需要struct test a;
	a.num1 = 3;
	a.num2 = 4;
	printf ("%d %d", a.num1, a.num2);
    // 输出：3 4
    return 0;
}
```

#### 写函数

```c++
#include <cstdio>

struct test {
	int max (int x, int y) {
		return (x > y) ? x : y;
	}
};

int main (void) {
	test a;
	printf ("%d", a.max(3, 4));
    // 输出：4
    return 0;
}
```

#### 隐式参数和this

```c++
#include <cstdio>

struct test{
	int num;
	
	int sum (int x) {
		return this->num + x;
	}

};

int main (void) {
	test a;
	a.num = 3;
	printf ("%d", a.sum(4));
    // 输出：7
    return 0;
}
```

##### 隐式参数

使用对象去调用函数，那么这个对象它自己也会成为参数传到参数中

这个参数不是你主动传的，也没有放到函数后面的参数列表中，所以就是隐式参数

使用时需要关键字**this**

##### this

大多数情况this可以省略

但以下情况不能（参数的名字和我成员变量名字相同时，如果我省略this，那么会辨别不出我想用的是参数列表中的变量还是类中的变量）

```c++
#include <cstdio>

struct test{
	int num;
	
	int sum (int num) {
		return this->num + num;
	}

};

int main (void) {
	test a;
	a.num = 3;
	printf ("%d", a.sum(4));
    return 0;
}
```

#### 结构体变量赋值

```c++
#include <cstdio>

struct test{
	int num1;
	int num2;
	

	test (int x, int y) {
		num1 = x;
		num2 = y;
	}

};

int main (void) {
	test a(3, 4);
	printf ("%d %d", a.num1, a.num2);
    // 输出：3 4
    return 0;
}
```

##### 赋值更简便的方法

```c++
#include <cstdio>

struct test{
	int num1;
	int num2;
	
	test () {}
	
	test (int x, int y) : num1(x), num2(y) {}
};

int main (void) {
	test a(3, 4);
	printf ("%d %d", a.num1, a.num2);
    // 输出：3 4
    return 0;
}

```



### inline



以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。

```c++
inline int add(int a, int b){return 下 + y;}
```

但仅针对短函数，另外，递归也不可用。

### opertaor

#### operator重载运算符的介绍

```c++
返回类型说明符 operator 运算符符号 (参数表) { 函数体 }
```

示例: 给node结构体重载小于号(首先比较x，如果x相同比较y)

```c++
struct node{
    int x, y;
    bool operator <(const node &a) const {  
        if (x != a.x) return x < a.x;  
        return y < a.y;  
    }
};
```

- `bool`: 这是函数的返回类型。operator< 是一个比较运算符，通常用于比较两个对象并返回一个布尔值（true 或 false）来表示第一个对象是否小于第二个对象。
- `operator<`: 这是重载的比较运算符。在C++中，你可以为自定义类型重载运算符，以便它们可以像内置类型一样使用。在这个例子中，我们重载了 < 运算符，以便可以比较两个 node 对象。
- `const`：表示这个引用指向的对象在函数内部不会被修改。
- `node`：这是参数的类型，即我们正在比较的另一个 node 对象。
- `&`：表示这是一个引用，而不是一个值拷贝，可以避免不必要的对象拷贝，提高性能。
- `a`：这是参数的名称，在函数体内部，可以通过 a 来访问传入的 node 对象。
- 第二个 `const`: 它表明这个函数是一个常量成员函数。这意味着它可以在常量对象上调用，因为调用这个函数不会改变对象的状态。如果没有这个尾随的 const，那么以下代码将会导致编译错误：


```c++
const node n1{1, 2};  
const node n2{2, 3};  
  if (n1 < n2) { // Error if operator< is not const  
    // ...  
}
// 因为 n1 是一个常量对象，所以你不能调用一个非 const 成员函数
```

#### 案例

##### 1、重载` +`号，返回值类型的使用

###### 结构体间相加得到结构体

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
struct node{
	int x, y;
    //返回值int 
	int operator +(const node &e)const {
        // 返回结果, 这里的+号为int间的+号，也就是普通的+号
		return e.x + x + e.y + y; 
	}
}f[N]; 
int main()
{
	f[1].x = 2, f[1].y = 10;
	f[2].x = 3, f[2].y = 11;
    // node之间的+以重载，返回值int
    int res = f[1] + f[2];
	cout << res <<endl;
	return 0;
 }
```

输出结果: 26 

解释: 相加的结果类型为填写+返回值的类型也就是int，相加规则：2+3+10+11

###### 结构体间相加得到整型(int)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
struct node{
	int x, y;
    //返回值node
	node operator +(const node &e) const{
		return {e.x + x, e.y + y}; 
	}
}f[N]; 
int main()
{
	f[1].x = 2, f[1].y = 10;
	f[2].x = 3, f[2].y = 11;
    // +返回值node(结构体) 类型
	f[3] = f[1] + f[2];
	cout << f[3].x << " " << f[3].y<<endl;
	return 0;
 }
```

输出结果：5  21

解释: （2+3)（10+11)

##### 2、重载<(小于号)，定义结构体排序规则

结构体的排序，就是用﻿<﻿来进行比较大小。因此只要重载运算符﻿<﻿即可自定义排序规则。

###### 按x从大到小排序，x相同时按y从小到大排序 

运算符重载实现

```c++
using namespace std;
const int N = 1000010;
struct node{
	int x, y;
    //用于比较大小返回值bool
	bool operator < (const node &e) const{
		if(e.x != x) return x > e.x;
		return y < e.y;
	}
}f[N]; 
int main()
{
	srand(time(0));
	cout << "排序前： " << endl; 
	for(int i = 1; i <= 5; i++)
	{
        // 生成0-9随机数
		f[i].x = rand() % 10; f[i].y = i;
		cout << f[i].x << " " << f[i].y << endl;
	}
    // 排序下标从1开始到5
	sort(f + 1, f + 1 + 5);
	cout << "排序后: "<<endl;
	for(int i = 1; i <= 5; i++)
		cout << f[i].x << " " << f[i].y << endl;
	return 0;
 }
```



排序前：
```5 1
4 2
4 3
0 4
7 5
```

排序后:

```7 5
5 1
4 2
4 3
0 4
```



sort传入比较函数cmp实现

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
struct node{
	int x, y;
}f[N]; 
bool cmp(node a, node b){
	if(a.x != b.x) return a.x > b.x;
	return a.y > b.y;
}
int main()
{
	srand(time(0));
	cout << "排序前： " << endl; 
	for(int i = 1; i <= 5; i++)
	{
        // 生成0-9随机数
		f[i].x = rand() % 10; f[i].y = i;
		cout << f[i].x << " " << f[i].y << endl;
	}
	sort(f + 1, f + 1 + 5, cmp);
	cout << "排序后: "<<endl;
	for(int i = 1; i <= 5; i++)
		cout << f[i].x << " " << f[i].y << endl;
	return 0;
 }
```

排序前：

```c++
9 1
8 2
2 3
9 4
5 5
```

排序后:

```c++
9 4
9 1
8 2
5 5
2 3
```

3、重载<(小于号)map，set等容器自带排序规则 
map容器中默认排序规则是按照键的大小从小到达排序，如果键值类型为字符串那么是按字符串字典序从小到大排序，那么键值类型为自己定义的结构体呢？答案是会报错，因为直接无法比较两个结构大小，这时就要自己定义了。

1. 定义比较方式即重载<，使map能按照此方式比较结构体大小

```c++
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x, y;
	bool operator<(const node &a) const {  
	    if (x != a.x) return x < a.x;  
	    return y < a.y;  
	}
}; 
int main()
{
	map<node, int> mp;
	mp[{3, 1}] = 1;  mp[{2, 3}] = 2;
	mp[{3, 2}] = 3; mp[{4, 3}] = 4;
	mp[{1, 3}] = 5;
	map<node, int>::iterator it = mp.begin();
	while(it != mp.end())
	{
		cout << (*it).first.x << " " << (*it).first.y << endl;
		it ++;
	}
	return 0;
 }
```

输出结果:

```c++
1 3
2 3
3 1
3 2
4 3
```

优先队列`priority_queue`也叫堆，`set`等等同样如此 

这里补充一个`pair<int, int> `(int类型可以更改)函数，其中自带重载的小于号，按first值从小到大，first值相同按second值从小到大，算法竞赛常用hh
————————————————

版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/weixin_74292291/article/details/131575920

### 增强型for循环

`for (元素的数据类型 变量 : 数组/容器)`   相当于变量代替每个元素的值

```c++
#include <cstdio>

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	for (int i : a) {
		printf ("%d ", i);
	}	// 输出：1 2 3 4 5 
    return 0;
}
```

因为取的是值，所以不能对里面的数据改变

```c++
#include <cstdio>

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	for (int i : a) {
		++i;
	}
	for (int i : a) {
		printf ("%d ", i);
	}	// 输出：1 2 3 4 5 
    return 0;
}
```

要想改变里面的内容，数据类型那里要加引用

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	for (int &i : a) {
		++i;
	}
	for (int i : a) {
		printf ("%d ", i);
	}	// 输出：2 3 4 5 6 
    return 0;
}
```

注意，增强型for循环的速度要比普通循环慢一些

auto关键字，会自动帮我们匹配类型

```c++
#include <cstdio>

int main (void) {
	int a[5] = {1, 2, 3, 4, 5};
	for (auto i : a) {
		printf ("%d ", i);
	}	// 输出：1 2 3 4 5 
    return 0;
}
```

如果想要用引用类型，写auto&

注意，auto也是C++11标准里的




### 文件操作

#### 一、输入输出流的概念

在C++中，输入输出是同流来完成的。C++的输出操作将一个对象的状态转换成一个字符序列，输出到某个地方。

输入操作也是从某个地方接收到一个字符序列，然后将其转换成一个对象的状态所要求的格式。

这看起来很像数据在流动，于是把接收输出数据的地方叫做目标，把输入数据来自的地方叫做源。
而输入和输出操作可以看成字符序列在源、目标以及对象之间的流动。

#### 二、文件流的概念

在C++里，文件操作是通过流来完成的。C++总共有输入文件流、输出文件流和输入输出文件流3种，并已将它们标准化。

- 要打开一个输入文件流，需要定义一个 ifstream类型的对象。->Input-stream          写操作
- 要打开一个输出文件流，需要定义一个 ofstream类型的对象。->Ouput-stream       读操作
- 如果要打开输入输出文件流，则要定义一个 fstream类型的对象。->File-stream       读写操作

这3种类型都定义在头文件 fstream 里。

- 一个输出流对象是信息流动的目标，ofstream是最重要的输出流。

- 一个输入流对象是数据流动的源头，ifstream是最重要的输入流。
- 一个iostream对象可以是数据流动的源或目标，fstream就是从它派生的。

#### 三、文件操作

可以总结出对文件进行操作的方法如下：

- 包含头文件 <fstream>

- 创建一个流对象

- 将这个流和相应的文件关联起来
- 文件操作流

```c++
#include<iostream>
#include<fstream>                 //1、包含输入输出流头文件
using namespace std;

void outstream(){

	ofstream ofs;   		  //2、打开一个相应的文件流
	ofs.open("mytest.txt");	  //3、流与文件关联上

};

int main(){
	return 0;

}
```


因为ifstream、ofstream和fstream这3个类都具有自动打开文件的构造函数，而这个构造函数就具有 open() 的功能。

因此，我们可以在创建流对象的时候就可以关联文件：ofstream myStream("myText.txt");

#### 四、只写

用一个指针指向一个文件，这个指针叫做**文件指针**通过文件指针可以对文件进行操作

位置指针：光标的位置。一般情况下指向文件开头。如果对文件进行读的操作，每输出一个字符，指针向后移动一位



##### 文件打开

`fopen`函数  （“文件名”，“操作方式”）

操作方式是指读还是写等

```c++
FILE *fp = fopen("./text.txt","r")
```

`FILE`可以对应理解为int，这里是文件操作类型

`./`指当前目录下

##### 操作方式

```c++
r  //只读  文件必须存在
w  //只写  存在则清除原有内容，不存在则重新创建
a  //追加  向文本文件增加数据       文件必须存在
rb //只读  为输入打开一个二进制文件  文件必须存在
wb //只写  为输出打开一个二进制文件  
ab //追加  为二进制文件追加内容
```

在方式后面加上`+`表示可读可写 比如`r+`

##### 文件关闭

`fclose`函数  （文件指针）

功能：关闭文件，释放文件指针

##### 实例

```c++
void fileWrite() {
	FILE* fp = fopen("./file/text", "w");//没有文件会创建文件，但在当前目录下，没有file这个文件夹，
    									//文件操作不能创建文件夹，需要先在当前目录下创建一个file文件，即可运行
	if (fp == NULL) {
		perror("");
		return;
	}
	char ch = fputc('a', fp);//输入字符，注意只能输入单个字符
	printf("%c", ch);
	fclose(fp);
}
```

当想输入多个字符时，要用while循环反复读入，或者用`fputs`

##### c++

头文件`fstream`

###### **步骤一：创建文件输出流对象并调用其函数，打开文件**

```c++
ofstream fout;//后者为文件名
fout.open("text.txt");//如果文件不存在，则创建；如果文件存在，则覆盖
```

文件名一般用全路径，存到指定文件中，方法如下：

```c++
“C:\Users\86166\Desktop\vs”  //错误：\为转义字符
R“(C:\Users\86166\Desktop\vs)”
"C:/Users/86166/Desktop/vs" //反斜杠写为斜杠
“\Users\86166\Desktop\vs”//仅限linux系统
```

打开文件的另一种方式

```c++
ofstream fout(R“(C:\Users\86166\Desktop\vs)”)
```



打开模式

```c++
ofstream fout(R“(C:\Users\86166\Desktop\vs)”, ios::out);
ofstream fout(R“(C:\Users\86166\Desktop\vs)”, ios::trunc);
ofstream fout(R“(C:\Users\86166\Desktop\vs)”);
```

以上三种方式等价：如果文件不存在，则创建；如果文件存在，则覆盖

```c++
ofstream fout(R“(C:\Users\86166\Desktop\vs)”， ios::app);//在文件末尾追加文件内容
ifstream fout(R“(C:\Users\86166\Desktop\vs)”， ios::in);//只读，打开已有文件，不会创建文件
```



###### **步骤二：判断打开是否成功**

```c++
if(!fout.is_open){
    cout<<"打开文件失败！";
    return 0;
}
```

打开失败主要原因有

- 目录不存在
- 磁盘空间已满
- 没有权限

###### **步骤三：写入数据**

```c++
fout<<"具体内容"//向文件中写入数据
```

###### **步骤四：关闭文件**

```c++
fout.close();
```



#### 五、只读



```c++
#include<iostream>
using namespace std;
int main() {
	FILE* fp = fopen("./touch.txt", "r");//在当前目录下打开touch文件
	if (fp == NULL) {//判断文件是否存在
		perror("");//如果不存在输出对应错误
		return 0;
	}
	while (1) {
		 char ch = fgetc(fp);//取光标后第一个字符
		 if (ch == EOF)break;//如果字符为空，退出
		 printf("%c", ch);
	}
	fclose(fp);//关闭文件
	return 0;
}
```

`EOF`为文件内容结束标志

```c++
if(!feof(fp))//如果没有到文件结尾的话
```

###### c++

```c++
ifstream fin(R“(C:\Users\86166\Desktop\vs)”， ios::in);//打开文件
if(!fin.is_open()){
    cout<<"打开文件失败！";
    return 0;
}

//法一
string sen;
while(getline(fin, sen)){//把fin中的一行内容存放在sen中
    cout << sen;
}

//法二
char sen[100];
while(fin.getline(sen, 100)){//此时getline是文件成员函数，不是全局函数
    cout << sen;
}//当一行内容超过指定字符数后会出错

//法三
string sen;
while(fin >> sen){
    cout << sen;
}
fin.close();
```



#### 六、读写

`fputs`或者`fgets`可读入或输出字符串 

`fputs`返回  0表示读入成功，-1表示读入失败

`fgets`返回指针，指向字符数组

这两个函数只能读入或者输出一整行，读入或者输出多行需要使用while循环

```c++
void fileReadWrite() {
	FILE* fp = fopen("./file/text.txt", "w+");
	if (fp == NULL) {
		perror("");
		return;
	}
	int fw = fputs("zbcd", fp);
	cout << fw << endl;
//此时光标已在d后面
	rewind(fp);//让光标回到文件开头
	char buf[128];
	char* str = fgets(buf, sizeof buf, fp);//从fp中读取
	cout << buf << str;

}
```

###### 格式化读

即按照一定格式要求读取文件

##### 法一：一切以字符串形式读取

```c++
char buf[4][20]={0};
fscanf(fp, "%s %s %s %s", buf[0], buf[1], buf[2], bud[3]);
for(int i = 0; i < 4; i++){
    puts(buf[i]);
}
```

```c++
//输出例
//强
//计算机12
//1
//100.0
```

##### 法二：以不同数字类型读取

```c++
char name[20]={0};
int cclass[20]={0};
int sex;
double score;
fscanf(fp, "%s %s %d %f\n", name, cclass, sex, score);
for(int i = 0; i < 4; i++){
    puts(buf[i]);
}
```

多重数据使用`while`循环

#### 七、格式化写

```c++
fprintf(fp, "%s\t%s\t%d\t%lf\n", "xxx", "xxx", 12, 10.0)
```

#### 八、创建文件夹

##### 1.mkdir函数

```c++
#include <direct.h>
#include <iostream>

using namespace std;

int main()
{
	string file = "E:\\test";

	if (0 != _mkdir(file.c_str())){
	// 返回 0 表示创建成功，-1 表示失败
		_mkdir(folderPath.c_str());   	
	}
return 0;

}
```

##### 2.access函数

```c++
#include <direct.h>
#include <iostream>
#include <io.h>

using namespace std;

int main()
{
	string folderPath = "E:\\test";

	if (_access(folderPath.c_str(), 0)){
	// 返回 0 表示创建成功，-1 表示失败
	_mkdir(folderPath.c_str());   	
	}
return 0;

}
```



##### 3.使用system()调用dos命令

```c++
#include <iostream>
using namespace std;

int main()
{
	string folderPath = "E:\\test";

	string command;
	command = "mkdir test " + folderPath;

	system(command.c_str());

return 0;

}
```



##### 4.使用Windows API函数

```c++
#include <windows.h>
#include <iostream>

using namespace std;

int main()
{
	string folderPath = "E:\\test1";

if (!GetFileAttributes(folderPath.c_str()) & FILE_ATTRIBUTE_DIRECTORY)
{
	bool flag = CreateDirectory(folderPath.c_str(), NULL);
	// flag 为 true 说明创建成功
}
else {
	cout << "Directory already exists." << endl;
}

return 0;

}
```

————————————————

原文链接：https://blog.csdn.net/T_T_T_T_/article/details/120217416

#### 九、二进制文件

##### 写文件

```c++
void outbin() {
	ofstream obin; //创建写出流对象

	obin.open("testbin.txt", ios::out | ios::binary);  //二进制方式打开

	Person p = { "李四",12,'男' }; 

	//把对象写入到obin
	obin.write((const char*)&p, sizeof(p));
	//关闭文件
	obin.close();
}
```

##### 读文件

```c++
//二进制方式读文件
void readbin() {
	
//包含头文件
ifstream inbin;

//创建流对象
inbin.open("testbin.txt", ios::in, ios::binary);

//判断是否打开文件
if (!inbin.is_open()) {
	cout << "文件打开失败!!" << endl;
	return ;
}
Person p;
inbin.read((char*)&p, sizeof(p));
cout << "姓名：" << p.name << "年龄：" << p.age << endl;

inbin.close();

}
```

打开文件流后完成操作之后一定要关闭文件流
————————————————
版权声明：本文为CSDN博主「Jemery-an」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43256263/article/details/127502981

#### 十、文件流迭代器

C++文件流迭代器 istreambuf_iterator 是用于输入流的迭代器之一，它可以让你通过使用迭代器的方式来遍历输入流中的字符，例如从文件中读取数据。

istreambuf_iterator 可以用于读取字符，但它不是一个标准的容器，因为它没有内存缓存和支持随机访问。相反，它只提供了输入流的单向迭代器，它的作用是简化从输入流中读取数据的操作。

以下是使用 istreambuf_iterator 从文件中读取数据的示例代码：

```c++
#include <iostream>
#include <fstream>
#include <iterator>
#include <string>

int main() {
    std::ifstream file("example.txt");
    std::istreambuf_iterator<char> begin(file);
    std::istreambuf_iterator<char> end;
    std::string contents(begin, end);
    std::cout << contents << std::endl;
    return 0;
}
```

在上面的示例代码中，我们使用 ifstream 打开了一个名为 “example.txt” 的文件，并创建了 istreambuf_iterator 类型的 begin 迭代器和一个默认的 end 迭代器。

然后，我们使用 std::string 的迭代器构造函数，将 begin 和 end 迭代器之间的字符范围转换为一个 std::string 对象，从而将文件中的所有内容读取到了内存中。

因此，istreambuf_iterator 提供了一种方便的方式，可以通过迭代器遍历输入流中的字符，而不需要手动编写循环逐个读取每个字符。
————————————————
版权声明：本文为CSDN博主「LewGarben」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_46017342/article/details/130395668

